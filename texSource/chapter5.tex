



\chapter{Implementação}
\label{implementacao}





Neste capítulo, são explicados os detalhes da implementação deste projeto, incluindo especificamente o projeto Django que inclui o sistema de informação com a aplicação web (frontend/backend) e API REST e também a aplicação mobile em Phonegap. Para além disso, é descrita a implementação da simulação em \textit{hardware} para o cenário descrito no capítulo anterior bem como o sistema de deteção de intrusos. 

Segundo o ciclo de vida de um software, estabelecido por \textit{Munish Kaur et al.}\cite{Saini2014} que analisámos na secção X.X, este capitulo irá incluir, em parte, a fase de \textit{designing} mas sobretudo a fase de \textit{coding}. 





\section{Sistema de informação}


Relativamente ao projeto Django, numa primeira fase procedeu-se à incorporação do \ac{SGBD} PostgreSQL através do psycopg2\footnote{http://initd.org/psycopg/docs/}. O psycopg2 consiste num adaptador entre o PostgreSQL com a linguagem de programação Python, que permite executar de formar eficiente qualquer \textit{script} em \ac{SQL}. É de notar que nesta fase inicial, encontram-se instalados algumas aplicações nativas do Django entre as quais, o  \texttt{django.contrib.auth} e  o \texttt{django.contrib.sessions}. Através delas é possivel verificar o total funcionamento da base de dados uma vez que permitem criar automática das tabelas associadas ao utilizadores, grupos, permissões e respetivos conteúdos, administração, sessões entres outros. Estas tabelas são fundamentais ao bom funcionamento do sistema uma vez que são consideradas no modelo de dados descrito na secção XX. 


Posteriormente, procedeu-se à criação dos diferentes \texttt{Models} conforme a nomenclatura apresentada nas tabelas X e X da secção XX. O excerto de código seguinte pretende ilustrar a criação do \texttt{Model} associado à tabela que representa a estrutura \acl{SM}, com o respetivo identificador e atributos.  Após a criação de cada \texttt{Models} procedeu-se à migração dos dados para o \ac{SGBD} onde era possível verificar que as tabelas tinham sido criadas, através da utilização da ferramenta gráfica pgAdmin III. De modo a testar a estrutura criada, procedeu-se à introdução de dados através da zona administrativa do Django (figura \ref{admingdjango}). Através dos dados introduzidos e descrevendo um cenário realista foi possível validar a estrutura e proceder à implementação da aplicação web e criação da \ac{API} \ac{REST}. 




\begin{lstlisting}[
language=Python,
showspaces=false,
basicstyle=\ttfamily,
numbers=left,
numberstyle=\tiny,
commentstyle=\color{gray},
basicstyle=\ttfamily\footnotesize
]
class SensorModule(models.Model):
	id = models.AutoField(primary_key=True)
	name = models.CharField(max_length=128)
	seding_time = models.IntegerField()
	status_sm = models.BooleanField(default=True)
	baterry_sm = models.IntegerField()
	localization_sm = models.CharField(max_length=128)
		
	def __str__(self):
		return "#"str(self.id) + " name_"+str(self.name)


\end{lstlisting}


\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.4]{prints-web/admindjango.png}
	\caption{Painel administrativo do Django }
	\label{admingdjango}
\end{figure}








\subsection{Sistema de registo e autenticação}

Primeiramente, procedeu-se à adaptação do template AdminLTE de modo a criar as páginas de autenticação e registo dos utilizadores. Como vimos anteriormente irão existir utilizadores distintos, uma vez que, de modo a identificá-los e a definir a sua permissões houve necessidade de criar grupos específicas. Foram então criados dois grupos:  \textit{company}, que identifica uma empresa e \textit{general}, que identificada um utilizador comum. O administrador do sistema é um utilizador que tem o estado de \textit{superuser} ativo, isto é, possui todas as permissões sem que estas lhe sejam atribuídas explicitamente.


\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/activitydiagram-autenticacao.pdf}
	\caption{Diagrama de atividades do processo de registo e autenticação}
	\label{activt-autent}
\end{figure}


Como vimos anteriormente, o \textit{company user} apenas poderá ser adicionado ao sistema pelo admistrador, tendo este também permissões de gerir todos os utilizadores registados. Por outro lado, os \textit{company user} tem a possibilidade de validar os \textit{general user} que se associam à sua empresa, tendo posteriormente acesso aos dados/conteúdos da empresa. Após o registo de um novo \textit{general user} e a validação por parte do \textit{company user}, existem notificações que são enviadas via email. Estas mensagens são enviadas recorrendo ao método \texttt{send\_mail}\footnote{https://docs.djangoproject.com/en/1.11/topics/email/} existente nativamente no Django pelo pacote \texttt{django.core.mail}, sendo construido através do módulo \texttt{smtplib}\footnote{Módulo que define objetos para sessões \ac{SMTP} https://docs.python.org/3/library/smtplib.html\#module-smtplib}. Na figura \ref{activt-autent} apresenta-se o diagrama de atividades que ilustra o processo de registo de um \textit{general user} que envolve o utilizador responsável pela empresa (company user). 








\subsection{Geração de alarmes}

No modelo de dados definido, cada sensor tem que ter obrigatoriamente associada uma entrada na tabela \texttt{AlarmsSettings} que permite definir o valor máximo e mínimo para o qual são gerados alarmes bem como as mensagens associadas que permitem informar o utilizador. 

A geração de alarmes é condicionada pela comparação do valor lido pelos sensores com o valor máximo e mínimo definidos para o sensor em questão. Uma vez que é necessária esta verificação para cada leitura, decidiu-se criar um \textit{trigger} em \ac{SQL} que execute este procedimento, sendo este executado a nível da \ac{SGBD} tornando o processo mais eficiente. Um \textit{trigger} permite que uma determinada sequência de comandos sejam executadas sempre que um determinado evento ocorre, neste caso uma adição. No anexo X encontra-se um \textit{stored procedure} (função) que implementa a sequência de comandos bem como a implementação do \textit{trigger} na linguagem \ac{SQL}. Na figura \ref{fluxoSP} encontra-se um diagrama de fluxo que permite ilustrar a lógica do \textit{stored procedure}. 



\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.5]{esquemas/diagramafluxoalarms.pdf}
	\caption{Diagrama de fluxo para geração de alarmes}
	\label{fluxoSP}
\end{figure}



Seguidamente são apresentadas algumas alternativas à implementação apresentada, pretendendo que estas sejam mais eficientes e igualmente competitivas às apresentadas pelas soluções apresentadas em XX. 

\begin{itemize}
	\item Análise do valor médio de cinco medições e respetivo desvio padrão 
	\item Análise dos dados, também conhecida por data analist......... falta desenvolver data mining  
\end{itemize}


O utilizador através da \textit{dashboard} e da aplicação \textit{mobile} poderá analisar os alarmes gerados bem como se o valor lido excede ou não atingiu o valor pretendido. Para além disso, é apresentada a mensagem pré-definida para que o utilizador possa tomar uma decisão.   


\subsection{Visualização dos dados e cálculos estatísticos}

O cliente do sistema ao aceder à \textit{dashboard} e pretender visualizar os detalhes de um determinado \acl{CM} ser-lhe-á apresentada uma lista de todos os \textit{Sensor Modules} que este possui. Juntamente com esta lista são apresentadas as caraterísticas principais de cada um, destacando os sensores existentes, o intervalo de tempo em que são enviadas dados, percentagem de bateria, coordenadas da localização do módulo e tipos de comunicação com o \acl{CM}. Complementarmente são apresentados quatro botões com icons sugestivos que permite realizar tarefas distintas.  

\begin{itemize}
	\item \faEdit \space (editar): possibilita editar as características enumeradas anteriormente para cada \acl{SM}. 
	\item \faTrash \space (remove): permite remover o \acl{SM} do \ac{CM}. 
	\item \faBarChart \space (visualização gráfica): é possível visualizar graficamente os dados lidos pelos diferentes sensores existentes no \acl{SM}. 
	\item \faDatabase \space (visualização tabular): faculta em vista tabular uma visualização dos dados lidos pelos sensores bem como a respetiva exportação em ficheiro \ac{CSV}. 
\end{itemize}


Em ambas as visualizações anteriormente descritas é possivel obter uma filtragem por data para os dados obtidos dos sensores de cada \acl{SM}. Esta filtragem pode ser efetuada através de sete formas diferentes: do dia, do dia anterior, dos últimos sete dias, dos últimos trinta dias, deste mês, do ultimo mês e selecionando a data de inicio e de fim especificamente. 


No que toca à visualização gráfica toda a representação foi concebida recorrendo à biblioteca ZingChart em \ac{JS}, sendo que toda a manipulação de dados é realizada a nível de \textit{backend} e posteriormente apresentada através dos \textit{templates} do Django. A análise estatística para o intervalo de data considerado permitirá ao cliente obter o valor máximo lido, o valor mínimo lido bem como o valor médio, sendo também todo o processamento realizado a nível de \textit{backend}. Para além disso, esta página também possibilitará a ativação/desativação remota dos atuadores existentes no terreno. 


Por fim, relativamente à visualização tabular os dados são apresentados em três campos distintas que representam o tipo de sensor, data e hora da leitura, valor lido e a escala. A tabela contém paginação sendo que é possível escolher o número de entradas que serão apresentadas (10, 25, 50 ou 100). Complementarmente, existe uma caixa de texto que permite ao cliente pesquisar pelos campos apresentados, para além disso é possível ordenar alfabeticamente ou numericamente esses. O cliente também poderá exportar os dados apresentados num ficheiro do tipo \ac{CSV} com a estrutura apresentada na tabela \ref{exportcsv}. Para a implementação desta funcionalidade foram utilizados os métodos \texttt{writer} e \texttt{writerow()} disponíveis no pacote csv do Python.  


\begin{table}[h]
	\centering

	\begin{tabular}{|l|l|l|l|l|}
		\hline
		ID & Sensor type & Scale & Date time & Value \\ \hline
		579 & Water valve & 0/1 & 2017-05-31 09:30:14.762099+00:00 & 1 \\ \hline
		580 & Temperature & C & 2017-05-31 09:33:15.451236+00:00 & 25 \\ \hline
		581 & Water level & 0/1 & 2017-05-31 09:33:15.505198+00:00 & 1 \\ \hline
	\end{tabular}
	\caption{Estrutura do ficheiro do tipo \ac{CSV} possível de exportação}
	\label{exportcsv}
\end{table}




\subsection{\ac{API}}


Tal como referido no capítulo anterior, para a implementação desta API do tipo REST foi utilizado o \textit{Django REST framework}. Para tal, instalou-se a aplicação \texttt{'rest\_framework'} no ficheiro de configuração do projeto Django, em \texttt{settings.py}. Para iniciar esta implementação procedeu-se à realização do \textit{quickstart} disponível no site oficial da framework. 

Primeiramente, procedeu-se à criação de um novo módulo \texttt{serializers.py} onde foram instanciadas todas as classes serializáveis\footnote{Consiste num processo de tradução de uma estruturas de dados ou de um objeto que pode ser armazenado (num arquivo ou buffer de memória) e reconstruido posteriormente  } para cada \texttt{Model} existente bem como  para os campos a considerar que possam ser usados na representação dos dados em formato \ac{JSON}. De seguida, desenvolveu-se o módulo \texttt{apiViews.py} onde são implementadas todas as classes baseadas na \texttt{APIView}. A classe \texttt{APIView} é uma subclasse da \texttt{View} (abordada no capítulo \ref{state}) tendo algumas diferenças: 

\begin{itemize}
	\item Na classe \texttt{View} são retornados objetos do tipo \texttt{HttpRequest} ou \texttt{HttpResponse}, enquanto que na \texttt{APIView} são objeto \texttt{Request} e \texttt{Response}.
	\item A classe \texttt{APIView} permite a implementação dos seguintes métodos \ac{HTTP}: 	\texttt{get()}, \texttt{post()}, \texttt{put()} e \texttt{delete()},
	\item Através da classe  \texttt{APIView} podem ser implementadas várias políticas da \ac{API} 
\end{itemize}

 
A titulo de exemplo, o excerto de código seguinte encontra-se a implementação do \textit{endpoint} \texttt{api/cm/\{pk\_or\_name\}} com o método GET

\begin{lstlisting}[
language=Python,
showspaces=false,
basicstyle=\ttfamily,
numbers=left,
numberstyle=\tiny,
commentstyle=\color{gray},
basicstyle=\ttfamily\footnotesize
]
#in serializers.py
class ControllerModuleSerializer(serializers.HyperlinkedModelSerializer):
	id_communication = CommunicationTypeSerializer()
	id_by_create = UserSerializer()

	class Meta:
		model = ControllerModule
		fields = ('id', 'name', 'id_communication', 'id_by_create', 'baterry_cm', 'status_cm', 'date_create','memory','localization_cm')

#in apiViews.py 
class ControllerModule_param(APIView):
	def get_object(self, pk_or_name):
		if pk_or_name.isdigit():
			try:
				return ControllerModule.objects.get(pk=pk_or_name)
			except ControllerModule.DoesNotExist:
				raise Http404
		else:
			try:
				return ControllerModule.objects.get(name__iexact=pk_or_name)
			except ControllerModule.DoesNotExist:
				raise Http404
	
	def get(self, request, pk_or_name, format=None):
		cm = self.get_object(pk_or_name)
		serializer = ControllerModuleSerializer(cm)
		return Response(serializer.data)

#in url.py
url(r'^api/cm/(?P<pk_or_name>[-\w]+)/$',views.ControllerModule_param.as_view()



\end{lstlisting}



Como descrito anteriormente, a autenticação desta API usa um método de autenticação via token. Para tal, foi necessário a instalar a aplicação \texttt{'rest\_framework.authtoken'} que fornece a estrutura \texttt{Token}, possibilitando a criação e modificação do token quando pretendido. Para que a autenticação seja possível é necessário incluir no módulo de configuração do Django o método pretendido, neste caso \texttt{'rest\_framework.authentication.TokenAuthentication'}

No anexo \ref{espcifAPIREST} encontram-se as especificações de cada \textit{endpoint} existente nesta API REST.






\subsection{Documentação da \ac{API}}

Para a utilização da documentação interativa da API REST foi utilizada a ferramenta Swagger. Para a sua utilização é necessário incluir a aplicação \texttt{'rest\_framework\_swagger'} no ficheiro \texttt{settings.py} do Django e seguindamente definir o \ac{URL} que lhe permitirá o acesso. Na figura \ref{docapi} encontra-se um exemplo ao consultar a documentação desta API. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{prints-web/api-doc.png}
	\caption{Documentação da API REST com a ferramenta Swagger}
	\label{docapi}
\end{figure}


\subsection{Aplicação web}

O utilizador da dashboard após autenticar-se ser-lhe-à apresentado todos os \textit{Controller Modules} a que tem acesso bem como as seguintes informações para cada um:


\begin{itemize}
	\item Mapa onde é possível localizar todos os módulos associados a um \acl{CM}; 
	
	\item Alarmes gerados pelos sensores que os \textit{Sensor Modules} possuem; 
	
	\item Últimos valores lidos pelo sensores dos \textit{Sensor Modules}; 
\end{itemize} 



Cada um dos mapas interativo permitirá localizar o \acl{CM} bem como os \textit{Sensor Modules} a si associados, sendo estes identificados por marcadores\footnote{Um marcador identifica uma localização no mapa. \\ \url{https://developers.google.com/maps/documentation/javascript/markers?hl=pt-br}} de diferentes cores, no caso do \acl{CM}, a vermelho e nos \textit{Sensor Modules}, a azul. A implementação destes mapas recorre à \ac{API} do Google Maps em \ac{JS}, permitindo receber a localização dos módulos em coordenadas \ac{GPS}. Ao clicar sob um determinado marcador este irá direcionar o utilizador para a página de detalhes do módulo em questão. 


Quando ocorre um  alarmes, o utilizador poderá verifica o motivo pelo qual este foi gerado, consultar a mensagem resultante bem como valor lido, tendo ainda a possibilidade de verificar/validar o alarme para que este não seja mais apresentado em destaque. Para além disso, o utilizador ao aceder à dashboard ser-lhe-ão apresentados os últimos valores lidos por cada sensor distribuídos por cada \acl{SM}. Adicionalmente, na página principal da plataforma são apresentados alguns valores estatísticos da mesma: numero de utilizadores registados, numero de \textit{Sensor Modules}, numero de \textit{Controller Modules} e numero de leituras que já foram recolhidas pelos diferentes sensores. 


A interface gráfica da plataforma permite ainda que o utilizador comum possa: 

\begin{itemize}
	\item Aceder à página de perfil que permite alterar as suas informações básicas e a password mas também consultar o token de autenticação na API. 
	
	\item Consultar, adicionar ou editar os detalhes dos \textit{Controller Modules} e dos \textit{Sensor Modules}
	
	\item Adicionar e respetiva consulta dos tipos de sensores e comunicação existentes
	
	\item Alterar o avatar existente através da ferramenta \textit{Gravatar} disponivel em \url{http://pt.gravatar.com/} 
\end{itemize}




gravatar 


Sempre que o utilizador executa uma determinada ação na plataforma este é notificado informando-o se a ação foi bem sucedida ou não. A implementação deste mecanismo recorre à estrutura de mensagens\footnote{\url{https://docs.djangoproject.com/en/1.11/ref/contrib/messages/}} do Django, também conhecida por mensagens de flash. 




\subsection{\textit{Deploy} do projecto}

Para implementar o projeto Django juntamente com um servidor web Apache 2.0 num \ac{VPS} Linux (Ubuntu 14.X), foram seguidos os seguintes passos: 


%https://jee-appy.blogspot.com.tr/2015/04/deploy-django-project-on-apache-using.html




\begin{enumerate}
	\item Instalação do Python na versão 2.7 bem como pip\footnote{Sistema de gestão de pacotes usado para instalar e gerir pacotes de software escritos na linguagem Python.} e respetivo \textit{upgrade} para a versão mais recente
	
	\texttt{sudo apt-get install python-pip python-dev build-essential}
	
	\texttt{sudo pip install --upgrade pip}
	
	
	\item Instalação do PostgreSQL na ultima versão e criação de uma base de dados com o nome salibd
	
	
	\texttt{sudo apt-get install postgresql postgresql-contrib}

	\texttt{createdb salibd}	
	
	
	\item Instalação do apache2 e do mod\_wsgi que fará a ligação do projeto Python com o servidor apache. Seguidamente dar reset ao apache2.
	
	\texttt{sudo apt-get install apache2}
	
	\texttt{sudo apt-get install libapache2-mod-wsgi}
	
	
	\item Configuração do virtualenv\footnote{\url{https://virtualenv.pypa.io/en/stable/}}, que consiste numa ferramenta para criar ambientes Python isolados. Por outro lado o virtualenvwrapper\footnote{\url{https://virtualenvwrapper.readthedocs.io/en/latest/}} permite uma fácil gestão do virtualenv, sendo que ao instalá-lo através do pip o virtualenv será instalado automaticamente. 
	
	
	\texttt{pip install virtualenvwrapper}
	
	 
	\item Criar um ambiente virtual (virtualenv) para o projeto. Para sua criação foi utilizada a opção \texttt{--system-site-packages} uma vez que a nossa aplicação terá que aceder a recursos fora do ambiente virtual, neste caso o PostgreSQL. 
	
	\texttt{mkvirtualenv exampleenv --system-site-packages}
	
	
	\item Adicionar projeto e instalar dependências. Primeiramente é necessário ativar o virtualenv. Seguidamente procedeu-se à instalação do Django e instalação dos requisitos da aplicação (através do ficheiro requirements.txt disponibilizado pelo IDE). 
	
	\texttt{workon exampleenv}
	
	\texttt{pip install Django}
	
	\texttt{cd /var/www}
	
	\texttt{git clone https://github.com/ruipoliveira/ThesisSalicornia-web.git}
	
	\texttt{pip install -r requirements.txt}
	
	

	

	\item Criação do virtual host. Terá que estar no directório \texttt{/etc/apache2/sites-available/} e criar um ficheiro \texttt{.conf} com o seguinte conteúdo. 
	
	\begin{lstlisting}[
	showspaces=false,
	basicstyle=\ttfamily,
	numbers=left,
	numberstyle=\tiny,
	commentstyle=\color{gray},
	basicstyle=\ttfamily\footnotesize
	]
	<VirtualHost *:80>
	ServerAdmin webmaster@mydomain.com
	ServerName 192.168.160.20
	ServerAlias http://192.168.160.20
	WSGIScriptAlias / /var/www/example.wsgi
	
	Alias /static/ /var/www/ThesisSalicornia-web/saliDashboard/saliapp/static/
		<Location "/static/">
			Options -Indexes
		</Location> 
	
	<Directory /var/www/ThesisSalicornia-web/saliDashboard>
	Order deny,allow    
	Allow from all
	</Directory>
	</VirtualHost>
	\end{lstlisting}
	
	Por fim, é necessário ativar esta configuração através do comando
	
	\texttt{a2ensite example.conf}
	
	
	\item Criação do ficheiro wsgi no directório \texttt{/var/www/}
	
	\begin{lstlisting}[
	language=Python,
	showspaces=false,
	basicstyle=\ttfamily,
	numbers=left,
	numberstyle=\tiny,
	commentstyle=\color{gray},
	basicstyle=\ttfamily\footnotesize
	]
	#file name 'example.wsgi'
	import os
	import sys
	import site
	# Add the site-packages of the chosen virtualenv to work with
	site.addsitedir('/var/www/.virtualenvs/exampleenv/local/lib/python2.7/site-packages')
	# Add the app's directory to the PYTHONPATH
	sys.path.append('/var/www/ThesisSalicornia-web/saliDashboard')
	sys.path.append('/var/www/ThesisSalicornia-web/saliDashboard/saliDashboard')
	os.environ['DJANGO_SETTINGS_MODULE'] = 'saliDashboard.settings'
	# Activate your virtual env
	activate_env=os.path.expanduser("/var/www/.virtualenvs/exampleenv/bin/activate_this.py")
	execfile(activate_env, dict(__file__=activate_env))
	from django.core.wsgi import get_wsgi_application
	application = get_wsgi_application()\end{lstlisting}
	
	
	\item Sincronizar da base de dados através do comando 
	
	\texttt{python manage.py migrate}
	
	 
	 
	 
\end{enumerate}




\subsection{Aplicação mobile}







\newpage
\section{Simulação em \textit{hardware}}

Nesta secção pretende-se explicar a implementação a nível de \textit{software} no contexto desta simulação para cada um dos micro-controladores. 


\subsection{Arduino}

No que diz respeito ao Arduino Nano (\acl{SM}), numa fase inicial,  procedeu-se à ligação dos diversos componentes  apresentados no capitulo anterior a uma \textit{breadboard} tal como se encontra apresentado no Anexo \ref{interlapd}. Para auxiliar o desenvolvimento de \textit{software} foi utilizada a versão 1.8.1 do \ac{IDE} do próprio Arduino\footnote{https://www.arduino.cc/en/Main/Software}. Seguidamente apresenta-se a implementação necessária a nível de sensores e de comunicação. 

\subsection{Sensores}



Foram desenvolvidos os seguintes métodos que permitem aceder aos valores lidos de cada um dos sensores. Para além disso, foi criado um método que permite alterar o estado da válvula para transferência de água. 

\begin{itemize}
	\item \texttt{int readTemperature(int port)}: é efetuada uma leitura no porto analógico e seguidamente realiazada uma conversão para para ºC (graus Celsius)
	
	\item \texttt{long readLuminosity(int port)}: 
	
	\item \texttt{int readWaterValve(int port)}: é efetuada uma leitura no porto digital através do método \texttt{digitalRead}. 
	
	\item \texttt{int readWaterLevel(int port)}: é efetuada uma leitura no porto digital através do método \texttt{digitalRead}.
	
	
	\item \texttt{void setWaterValve(int port, int state)}: se a variável \texttt{state} for 1 então o porto é colocado a \texttt{HIGH} (1) através do método \texttt{digitalWrite}, caso contrário é colocado a \texttt{LOW} (0)
	
\end{itemize}

Inicialmente procedeu-se à leitura de cada sensor de forma individual de modo a garantir o seu total funcionamento. Sempre que é feita um pedido de leitura dos sensores pelo \ac{CM} os valores são enviados com o seguinte formato: 

\begin{equation} 
\label{eq:someequation}
\texttt{<temperatura>;<nível\_água>;<luminosidade>;<estado\_válvula>}
\end{equation}

\subsection{Comunicação}


Numa primeira fase procedeu-se à comunicação entre o \ac{SM} e \ac{CM} através de porta série. Seguidamente resolveu-se incorporar o módulo bluetooth de modo a tornar cada módulo independente. De módulo de interagir com o módulo bluetooth utilizou-se o package \texttt{SoftwareSerial.h} disponível no Arduino. Decidiu-se que caso o módulo bluetooth recebesse valores de 0 a 2 tinha diferentes comportamentos: 

\begin{itemize}
	\item \textbf{0}: ativação (ligar) da válvula; 
	\item \textbf{1}: desativação (desligar) da válvula; 
	\item \textbf{2}: recebe dados obtidos pelos sensores no formato definido em (\ref{eq:someequation})
\end{itemize}

Antes de proceder à implementação de envio e receção de dados por bluetooth no Raspberry Pi 3 optou-se por testar este mecanismo através de uma aplicação Android existente na \textit{Play Store} chamada de \textit{Bluetooth Terminal HC-05}\footnote{https://play.google.com/store/apps/details?id=project.bluetoothterminal}

\subsubsection{Raspberry Pi}


\subsubsection{Comunicação}


Como é possível observar na figura \ref{esquemcomm}, para a comunicação no Raspberry Pi (\ac{CM}) entre o Arduino (\ac{SM}) foi utilizado o modulo interno de bluetooth 4.1 que este incorpora no seu hardware. Para tal, foi desenvolvido um \textit{script} em Python que permite o seguinte: 


\begin{enumerate}
	\item Verificar dispositivos bluetooth disponíveis
	\item Estabelecer conexão com módulo HC-06 através de um socket para comunicação utilizando para isso o \textit{package} \texttt{socket} do python. 
	\item Aceder à API para verificar estado da válvula de admissão de águas e enviá-lo através do socket utilizando o método \texttt{send()} 
	\item No caso se ser enviado o digito 1 a válvula será aberta, enquanto que se for enviado o digito 2 a válvula é fechada. 
	\item No caso de ser enviado o digito 2, o socket ficará à espera de receber os dados lidos pelos sensores, utilizando para isso o método \texttt{recv()}
	\item Após receber os dados lidos, é efetuado algum processamento para que os dados sejam enviados através da API. 
	\item Todos os pontos 3 a 6 são repetidos com um atraso igual ao seding time definido o sensor module na dashboard. 
\end{enumerate}

Para permitir o acesso aos recursos do sistema Bluetooth foi utilizada uma extensão (\textit{package}) do Python denominado de \textit{pybluez}\footnote{https://github.com/karulis/pybluez}. 




\subsection{Considerações finais}


>1 fase testar coneccao arduino to rasp via porta serie; foi criado um script em python para processar info e enviar para o servidor através da API 

>2 fase : necessidade de tornar um módulo isolado sem necessidade de fio; foi testado um modulo wifi e bluetooth; 

>neste contexto modulo wifi nao!... pretende-se que os sensor moduels sejam de baixo custo e low power. foi utilizado um modulo bluetooth; foi testada a conexao da comm bluetooth através de uma client disponveil na google play bluetooth terminal HC-05 


> 
pq nao foi usado um sensor de salinidade? nao havia orçamento.. 









\newpage
\section{Sistema de deteção de intrusos}





No que toca ao desenvolvimento do sistema de deteção de intrusos, optou-se por utilizar o package picamera. Este pacote fornece  uma interface em Python (disponível para qualquer versão) para o módulo de câmara Raspberry Pi\footnote{http://picamera.readthedocs.io/en/release-1.13/}, permitindo uma fácil interação entre a aquisição da imagem e respetivo processamento. Neste contexto optou-se obviamente por utilizar a interface Python da biblioteca do OpenCV.



\subsection{Algoritmos de deteção de intrusos}
% artigo http://lear.inrialpes.fr/people/triggs/pubs/Dalal-cvpr05.pdf

De modo a estudar alguns algoritmos de deteção de pessoas foram estudados alguns artigos neste contexto. 


Para a resolução deste problema foi efetuados 


HOGDescriptor: classe que implementa um histograma de gradientes orientado ( [Dalal2005] ) detetor de objetos. 

hog = cv2.HOGDescriptor()
hog.setSVMDetector(cv2.HOGDescriptor\_getDefaultPeopleDetector())




Usado biblioteca do opencv que permite detectar 
HOGDescriptor


Deteção de intrusos: 

http://www.pyimagesearch.com/2015/11/09/pedestrian-detection-opencv/



versão simplificada: http://www.pyimagesearch.com/2015/02/16/faster-non-maximum-suppression-python/



Servidor em falsk 


deploy 
https://iotbytes.wordpress.com/python-flask-web-application-on-raspberry-pi-with-nginx-and-uwsgi/



Dataset: %http://www.robots.ox.ac.uk/ActiveVision/Research/Projects/2009bbenfold_headpose/project.html


é usado um detector HOG juntamente com um classificador linear SVM 





parametros do método detectMultiScale do opencv 

\begin{itemize}
	\item \texttt{img}: parâmetro obrigatório. 
	\item \texttt{hitThreshold}: parâmetro opcional. 
	\item \texttt{winStride}: parâmetro opcional. 
	\item \texttt{padding}: parâmetro opcional.  Os valores típicos para preenchimento incluem  (8, 8) ,  (16, 16) ,  (24, 24) , e  (32, 32) .
	
	
	\item \texttt{scale}: parâmetro opcional. 
	\item \texttt{finalThreshold}: parâmetro opcional. 
	\item \texttt{useMeanShiftGrouping}: parâmetro opcional. 
\end{itemize}





Neste contexto apenas foram utilizados os seguintes parâmetros winStride, scale, padding. 



\subsection{Testes}

Foram considerados 4 frames de imagens .... e no apêndice X




\subsection{Implementação}


%\subsection{Flask}

Flask é considerada uma microframework web desenvolvida em Python e baseado nas bibliotecas WSGI Werkzeug e Jinja2. Escolhi esta microframework pois pretende-se que esta seja executada num microcontrolador com baixos recursos. Para além disso, considera-se ser de fácil aprendizagem relativamente ao Django (já abordado na capitulo XX) e com uma ótima documentação. 




%\subsection{Servidor web NGNIX}

\section{Considerações finais}





