

\chapter{Sistema de controlo e monitorização: arquitetura e modelação}


Este capítulo tem como objetivo a descrição do sistema que resultou do trabalho prático
desta dissertação. Para esse fim, cada elemento pertencente ao sistema é caracterizado de
acordo com as suas funções, especificidades e respectiva arquitetura. É também descrito como os elementos interagem entre si. Para além disso, é apresentado todo o processo de modelação do sistema tendo por base os requisitos adquiridos pelo cliente. 



%Dashboard - Interface que apresenta a informação mais importante para o utilizador de forma apelativa, tornando mais fácil a interacção e respetiva leitura


% Mockups - Design que a plataforma deverá apresentar no fim do seu desenvolvimento.



\section{Descrição global do sistema}

Este sistema tem como objetivo a supervisão remota da produção de salicornia,  permitindo não só a monitorização dos dados adquiridos pelos sensores, como também da atuação remota de determinados comandos. Neste contexto também será possível a aquisição de imagens que possibilitará a deteção de intrusos nas quintas onde se produz esta espécie.


\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.40]{esquemas/global_arquitetura.pdf}
	\caption{Ilustração principais componentes}
	\label{componentesall}
\end{figure}



O esquema da figura \ref{componentesall} ilustra todos os componentes de um modo geral e as diferentes plataformas com que o cliente pode interagir. 


Como vimos no capitulo 3, uma plantação de  salicórnia carece de um controlo relativamente fino de certos parâmetros ambientais sobretudo da salinidade do terreno onde ela cresce. A salinidade do terreno depende, por sua vez, das chuvas, da salinidade da água dos canais da ria. Nas quintas onde se cultiva salicórnia, a produção faz-se numa espécie de leiras limitadas por pequenos canais de irrigação. Esses canais podem ser cheios de água salgada proveniente dos esteiros que rodeiam a quinta. Essa operação implica a abertura de válvulas de admissão dessa água, medida do nível da maré nos canais, monitorização da qualidade e salinidade da água exterior.



\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.55]{esquemas/leiras-comm-geral.pdf}
	\caption{Ilustração da distribuição dos módulos em leiras para produção de salicornia }
	\label{leira}
\end{figure}


Tal como ilustrado na figura X, pretende-se que sejam colocados modulos com sensores - \ac{SM} - distribuídos estrategicamente por cada leira. Cada um desses modulos irá comunicar com um módulo central - \ac{CM} -, originando uma topologia de rede em estrela.  Por sua vez, este módulo irá comunicar diretamente com a servidor que possibilitará que os dados sejam tratados e disponíveis para visualização ao cliente. Pressupõe-se portanto que este ultimo módulo tenha necessariamente ligação à rede de modo a conseguir consumir a API REST por HTTP desenvolvida para o efeito. 



\newpage
\section{Componentes}

No contexto desta dissertação é necessário reter dois conceitos principais, são eles: 

\begin{itemize}
	\item \textbf{\textit{\acl{SM}}:} consiste num módulo responsável pela aquisição de dados provenientes dos mais diversos tipos de sensores.
	
	
	\item \textbf{\textit{\acl{CM}}:} consiste num módulo responsável pela receção dos dados/estados do \acl{SM} e respetivo envio para a \textit{cloud}.  
	
\end{itemize}


A figura \ref{esquema1}, ilustra três \acl{SM} que comunicam com um \acl{CM}. Cada um desses \acl{SM} que possui um conjunto especifico de sensores, comunica com \acl{CM} através de um determinado modulo de comunicação. Posteriormente, o \acl{CM} possui um determinado protocolo de comunicação que permite a utilização de uma API REST criada para o efeito. 




\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{esquemas/general-electronic-modules.pdf}
	\caption{Esquema de componentes da comunicação de três \ac{SM} com um \ac{CM}}
	\label{esquema1}
\end{figure}


Seguidamente serão especificados todos os detalhes de cada modulo, uma vez que serão considerados na modelação de todo o sistema. 


\subsection{\acl{SM}}



Um \acl{SM} consiste num microcontrolador responsável pela aquisição de dados provenientes dos mais diversos tipos de sensores. Cada \acl{SM} terá que utilizar um determinado módulo de comunicação de modo a possibilitar a comunicação com um módulo central. Para além disso, pretende-se que o sensor module possa ter controlo sobre si, ou seja, inteligência própria. 

Prentede-se que este módulo seja identificado por um determinado nome, possua uma bateria que permita a sua mobilidade, um ou vários modulos de comunicação que permita comunicar com um módulo centrar, uma memoria e um módulo \ac{GPS} que permita aceder à sua localização. Para além disso, um \acl{SM} terá que possuir um ou vários sensores.  





\subsection{\acl{CM}}



\acl{CM} consiste num microcontrolador responsável pela receção dos dados preveniente dos \acl{SM}. Pretende-se que este módulo envie informações para os \acl{SM} quando requisitados pelo utilizador. O principal objetivo deste módulo consiste em receber a informação proveniente dos \ac{SM} e respectivo envio para um servidor em \textit{cloud}. 

Pretende-se que este módulo seja identificado por um determinado nome, tenho um  módulo de comunicação que possibilite o envio de dados para o servidor e um campo que nos permita definir o tempo de receção desses dados. Para alem disso, pretende-se que exista um módulo de \ac{GPS} que permita localizar o \acl{CM} em caso de robo.
 





\newpage

%\section{Design funcional}






\section{Análise de requisitos}

Durante o desenvolvimento um software pressupõe-se que os seus intervenientes sigam determinadas metodologia para o seu programa possa revolucionar a vida de um grupo em especifico ou até mesmo da sociedade. 


O ciclo de vida do desenvolvimento de um software, também conhecido como \ac{SDLC}, é composto genericamente por quatro fase principais: concepção, projeto, criação e a implementação. Antes do \ac{SDLC}, o processo de desenvolvimento do software foi tomado como atividade informal sem regras e padrões formais. Isso poderá levar a vários problemas, tais como o atraso no desenvolvimento, aumento de custos e baixa qualidade do software criado. 

O ciclo de vida do desenvolvimento de um software dá o padrão necessário e as etapas para o desenvolvimento de um software com qualidade. Existem enumeros modelos e visões para o ciclo de vida de desenvolvimento, o que a seguir descrevo foi considerado por Munish Kaur \cite{Saini2014}. A figura \ref{sdlcartic} mostra as várias etapas que compõe este modelos e que seguidamente são descritas. 


\begin{figure}[!htb]
	\centering
	\includegraphics[scale=0.6]{esquemas/desenvolvimentoSW.pdf}
	\caption[Fase de desenvolvimento de um software ]{Fase de desenvolvimento de um software (Adaptado de \cite{Saini2014})}
	\label{sdlcartic}
\end{figure}




\begin{itemize}
	\item \textbf{Análise de viabilidade}: nesta fase é analisada a viabilidade do projeto, sendo analisados dados de entrada e saida, processamento necessário, análise de custos e planeamento do projeto. Nesta fase é incluida a viabilidade técnica em termos de software, hardware e pessoas qualificadas. 
	
	\item \textbf{Analise e especificação de requisitos}: nesta fase são recolhidos e analisados os requisitos necessário para a elaboração do \textit{software}. Pretende-se que no final desta fase sejam conhecidos os vários requisitos do software e seja também criado um documento que os especifique. 
	
	\item  \textbf{\textit{Designing}}: consiste na tradução dos requisitos especificado na fase anterior para a estrutura lógica.Pretende-se que seja elaborado um documento de especificação do \textit{design}. 
	
	
	\item  \textbf{\textit{Coding}}: o programação real é elaborada nesta fase. O documento de \textit{design} é traduzido para o código-fonte numa determinada linguagem de forma a que possa ser executado. 
	
	\item \textbf{Testes}: o código-fonte gerado na fase anterior é testado usando vários cenários de testes. São usadas várias técnicas de teste para avaliar a correção e validação do \textit{software}. 
	
	\item  \textbf{Implementação}: o software desenvolvido é implementado para que possa ser disponbilizado ao utilizador para uso real. Pretende-se que o utilizado do sistema possa reportar erros ou problemas quando encontrados. 
	
	\item  \textbf{Manutenção}: o software poderá sofrer alterações que possam solucionar problemas que tenham ocorrido. Esta fase é responsável pela pós-implementação e manutenção do software para o seu bom funcionamento.
	
\end{itemize}




%http://www.sersc.org/journals/IJSEIA/vol8_no3_2014/38.pdf




A forma como um software realiza as tarefas para as quais foi desenvolvido determina a eficiência de execução do mesmo\cite{Requirementsengineering}. O levantamento de requisitos é umas das fases essenciais no processo de desenvolvimento de um determinado sistema, que nos leva a entender o que o cliente deseja ou acredita precisar levando-nos à criação dos processos de negócio do sistema. 


Seguidamente são apresentados os requisitos funcionais e não funcionais do sistema. 




\subsection{Requisitos funcionais}


Os requisitos funcionais descrevem os critérios que devem ser usados para avaliar as funções especificas ou os comportamentos de um determinado sistema. Seguidamente são apresentados os requisitos funcionais propostos pelo cliente no contexto deste projeto para as duas plataformas disponíveis: web (dashboard) e mobile. 


\textbf{Aplicação mobile (dashboard)}


\begin{itemize}
	\item A interface do sistema deve permitir que o utilizador, seja ele qual for, entre ou faça \textit{login} no sistema. 
	
	\item A interface do sistema deve permitir que o utilizador, seja ele qual for, saia ou faça \textit{logout} no sistema.
	
	\item O dashboard deverá permitir que qualquer utilizador possa recuperar a sua chave de acesso ao sistema.
	
	\item O sistema deve permitir que qualquer utilizador se possa registar no sistema, embora tenha que estar obrigatoriamente associado a uma empresa.
	
	\item O utilizador comum só terá acesso à sua área reserva após a validação por parte da empresa.   
	
	\item O dashboard deverá permitir ao administrador a adição de novas empresas e a gestão de todos os utilizadores. 
	
	\item O sistema deve permitir que qualquer utilizador possa adicionar, editar ou remover: 
	\begin{itemize}
		\item Tipos de sensores
		
		\item Tipos de comunicação
		
		\item Controller modules com as suas caracteristicas
		
		\item Tipo de comunicação a um controller modules que permite a comunicação como servidor 
		
		\item Sensor modules a um determinado controller modules e as suas características 
		
		\item Um ou vários tipos de comunicação de um Sensor moduel
		
		\item Um ou vários sensores a um sensor module em que cada sensor é de um determinado tipo 
		
	\end{itemize}
	
	\item Visualizar graficamente os dados de cada sensor para um determinado \ac{SM}. 
	
	
	\item Visualizar em modo tabular (dataset) os dados de cada sensor para um determinado \ac{SM}. 
	
	\item Em cada uma das visualizações anteriormente descritas, pretende-se que seja possível uma filtragem por data
	
	
	\item O sistema permitirá a exportação dos dados de um determinado \ac{SM} em formato \ac{CSV}. 
	
	
	\item  Consultar a documentação da API 
	
	\item Consultar o token de autenticação da API 
	
	
	\item Alterar configurações do utilizador 
	
	
	
\end{itemize}


\textbf{Aplicação mobile}



\begin{itemize}
	\item A interface da aplicação mobile deve permitir que o utilizador, seja ele qual for, entre ou faça \textit{login} no sistema. 
	
	\item A interface da aplicação mobile deve permitir que o utilizador, seja ele qual for, saia ou faça \textit{logout} no sistema.
	
	
	\item Visualizar graficamente os dados de cada sensor para um determinado \ac{SM}. 
	
	\item Receber alarmes quando um determinado valor lido está fora do estipulado.
	
	
\end{itemize}



\subsection{Requisitos não funcionais}


Requisitos não funcionais são todos os requisitos da aplicação relacionados com
performance, escalabilidade, segurança, disponibilidade e usabilidade. Estes não são
necessariamente pedidos pelo cliente. 


\begin{itemize}
	\item O sistema deverá executar em qualquer plataforma, tanto web como mobile. 
	
	
	\item A base de dados deve ser protegida para acesso apenas a utilizadores autorizados. 
		
	
	\item O sistema deverá disponibilizar uma API para que possam ser criados novos produtos com base neste 
	
	\item Deverá ser usada, na medida do possível, tecnologias sem qualquer custo para o cliente (\textit{opensource}). 
	
	\item Pretende-se que o sistema possa ser adaptado a qualquer outro contexto. 
	

	
	
\end{itemize}



\section{Modelação}

A conceção de uma arquitetura envolve o estudo e modelacao de compontes que sao necessários para a elaboracao da mesma, bem como a analise dos casos de uso, modelos de dados e diagramas de fluxos, entre outros, para melhor entender como emparelhar a estrutura pretendida. Na secção será... %% rever... .................. 



\subsection{Entidades envolventes}




No contexto do sistema descrito existem três entidades distintas que são importantes descrever: 

\begin{itemize}
	
	\item \textbf{General user}: este poderá registar-se e associando-se a uma determinada empresa registada no sistema. Após a validação por parte da empresa, este utilizador poderá aceder à sua área reservada através das dashboard ou da aplicação mobile. 
	
	\item \textbf{Company user}: utilizador que gere todos os general users que se possam associar à sua empresa. Deste modo, este utilizador poderá validar os general users que a si se associam ou eliminá-los.  
	
	\item \textbf{Administrador}: vulgarmente denominado por Admin. Pretende-se que apenas exista uma único administrador. Genericamente este utilizador tem a possibilidade de poder adicionar novas empresas ao sistema, isto é, criar novas utilizador com permissões especificas. 
	
\end{itemize}




\subsection{Casos de uso}


Nas figuras \ref{usedash} e \ref{useMobile} encontram-se representados os esquemas dos casos de uso da \textit{dashboard} (denominada por saliDashboard) e da aplicação \textit{mobile} (denominada por saliMobile), respectivamente.
Seguidamente serão descritos cada um dos casos de uso para as duas plataformas. De notar que todos os casos de uso na aplicação mobile também se encontram disponíveis através da dashboard. 


\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/use-case-web.pdf}
	\caption{Casos de uso para a aplicação web (dashboard) }
	\label{usedash}
\end{figure}


\newpage
\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/use-case-mobile.pdf}
	\caption{Casos de uso para a aplicação mobile}
	\label{useMobile}
\end{figure}





\begin{itemize}
	\item \textbf{Login no sistema}: qualquer utilizador (general user, company user ou admin) poderá aceder ao sistema tendo para ir que possuir uma conta registada e validada no caso do user general. Após a validação das suas credenciais (username e password) o utilizador poderá aceder à pagina inicial da dashboard e a todo o seu conteúdo. Este caso de uso encontra-se disponível para os dois tipos de plataformas. 
	
	
	\item \textbf{Logout no sistema}: qualquer utilizador (general user, company user ou admin) poderá sair da sistema tendo que para isso tenha que estar obrigatoriamente logado no sistema. Após o logout ser-lhe-á apresentado novamente a página de login. Este caso de uso encontra-se disponível para os dois tipos de plataformas. 
	
	
	\item \textbf{Recuperar password}: qualquer utilizador (general user, company user ou admin) poderá recuperar a sua password de acesso ao sistema, para isso, terá que introduzir o seu email e posteriormente ser-lhe-á envia o acesso que possibilita a redefinição da mesma. 
	
	
	
	\item \textbf{Adicionar, editar, remover tipos de comunicação}: qualquer general user ou company user poderá adicionar, editar ou remover os tipos de comunicação existentes no sistema. Ao  adicionar, o utilizador terá que introduzir um nome, um caminho relevante para o tipo de comunicação e selecionar um icon ilustrativo. No caso da remoção, esta ação apenas é possível caso o tipo de comunicação não se encontre em utilização por nenhum \ac{CM} ou \ac{SM}.  
	
	\item \textbf{Adicionar, editar, remover tipos de sensores}: qualquer general user ou company user poderá adicionar, editar ou remover os tipos de sensores existentes no sistema. Ao  adicionar, o utilizador terá que introduzir um nome que o identifique, uma fonte de dados ou a escala dos dados  e um icon que identifique o sensor. Para além disso, o utilizador terá que escolher uma cor que identifique o tipo de sensor na dashboard. No caso da remoção, esta ação apenas é possível caso o tipo de sensor não se encontre em utilização por nenhum \ac{SM}.   
	 
	
	\item \textbf{Adicionar, editar, remover um controller module}: qualquer \textit{general user} ou \textit{company user} poderá adicionar, editar ou remover um controller module existente no sistema. Neste caso, pressupõe-se que o utilizador possua um micro-controlador com as seguintes características que podem ser adicionadas: determinado nome que o identifique, valor da memória RAM em MB, estado inicial (ativo ou desativo) e um modulo de comunicação que permita comunicar com o servidor web. Estas características são possíveis de alteração. Pretende-se que o controller module possa ser removido tendo \ac{SM} a sí associado, sendo estes também removidos dos sistema. 


	\item \textbf{Adicionar, editar, remover um sensor modules}: qualquer \textit{general user} ou \textit{company user} poderá adicionar, editar ou remover um sensor module existente no sistema. Pressupõe-se o utilizador possui um determinado micro-controlador com um ou mais sensores. Para adicionar o \ac{SM} à plataforma o utilizador terá que atribuir um nome que o identifique, definir qual o seu estado inicial (ativo ou desativo), escolher que tipos de comunicação possam estar presentes e definir o intervalo de tempo para o qual pretende receber os dados lidos pelos sensores. Para além disso, permite associar ao \ac{SM} os sensores presentes e definir o valor máximo e minimos para o qual são gerados alarmes e respectivas mensagens informativas. Todos os dados são possíveis de edição.  
	

	
	\item \textbf{Receber notificações (gerar alarmes)}: sempre que um valor lido por um determinado sensor sai fora do limite imposto (valor máximo e valor mínimo) é gerado um alarme para o utilizador de modo a que este possa intervir. Este caso de uso encontra-se disponível para os dois tipos de plataformas. 
	
	
	\item \textbf{Visualizar gráficamente os dados lidos pelos sensores}: 
	
	
	Este caso de uso encontra-se disponível para os dois tipos de plataformas. 
	
	
	\item Visualizar tabularmente os dados lidos pelos sensor
	
	\item \textbf{Exportar dados lidos por um sensor module}: qualquer \textit{general user} ou \textit{company user} poderá exportar os dados lido pelos sensores para um ficheiro do tipo \ac{CSV} para uma data especificada.
	
	\item \textbf{Visualizar a localização dos módulos (SM/CM)}: qualquer \textit{general user} ou \textit{company user} ao aceder à dashboard ser-lhe-à apresentado um mapa para cada \ac{CM} com a sua localização e dos seus respetivos \ac{SM}. 
	
	
	\item \textbf{Consultar a documentação da API}: qualquer \textit{general user} ou \textit{company user} poderá aceder à dashboard para consultar a documentação da API existente. 
		
	\item \textbf{Consultar token de autenticação}: qualquer \textit{general user} ou \textit{company user} poderá aceder ao token de autenticação para utilização da API. 
	

	
	\item \textbf{Validar general user}: qualquer company user tem a possibilidade de validar os general users que a si se associam. Sempre um novo general user é registado no sistema o comapny user é notificado via email. Posteriormente, caso o general user seja validado este também receberá um email de confirmação.  
	
	\item \textbf{Remove general user}: qualquer company user tem a possibilidade de remove os general users que a si estão associados. 
	
	
	\item \textbf{Remover sensor modules e controller modules }: o admin do sistema tem a possibilidade de remover os sensores modules e/ou controller modules existentes no sistema. 
	
	
	\item \textbf{Visualizar todos os sensor modules e controller modules}: o admim do sistema tem a possibilidade de visualizar todos os sensores modules e controller modules existentes no sistema de modo a alertar os clientes em caso de anomalias. 
	
	
	\item \textbf{Criar um novo company user}: o admim tem a possibilidade de adicionar novos company user ao sistema, sendo para isso necessário 
	
	\item \textbf{Remover um company user}: o admim tem a possibilidade de remover qualquer company user registado no sistema.
	
	
\end{itemize}







De acordo com a figura \ref{useMobile} , é possível descrever os seguintes casos de uso: 






\newpage
\subsection{Modelo de dados}

Depois da análise de requisitos desenhou-se um modelo de dados que permitisse modelar todo o sistema descrito, obtendo-se assim o seguinte esquema relacional apresentado na figura \ref{esquemarelacional}.





\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/database_tese.pdf}
	\caption{Esquema relacional da estrutura da base de dados}
	\label{esquemarelacional}
\end{figure}


Nas tabelas \ref{tabeladb1} e \ref{tabeladb2} são descritos descritos cada uma das tabelas de dados existentes neste sistema, evidenciando as chaves primária e estrangeiras de cada uma. 



\newpage
\begin{landscape}
	
\begin{table}[]
	\centering

	\label{tabeladb1}
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|l|l|}
		\hline
		\textbf{Nome da tabela} & \cellcolor[HTML]{EFEFEF}\textbf{Chave primária (\acs{PK})} & \cellcolor[HTML]{EFEFEF}\textbf{Chave estrangeira (\acs{FK})} & \cellcolor[HTML]{EFEFEF}\textbf{Descrição} \\ \hline
		\textbf{User} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos \\ utilizadores inseridos no sistema\end{tabular} \\ \hline
		\textbf{Token} & \begin{tabular}[c]{@{}l@{}}authtoken\_token\_pkey\\ (character varying(40))\end{tabular} & user\_id & \begin{tabular}[c]{@{}l@{}}Possui o token de autenticação \\ do utilizador para a API\end{tabular} \\ \hline
		\textbf{Group} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Possui todos os grupos \\ existentes: general user,\\ company user e admin\end{tabular} \\ \hline
		\textbf{UserGroups} & id (auto-incrementado) & user\_id group\_id & \begin{tabular}[c]{@{}l@{}}Permite associar um \\ utilizador a um\\  determinado grupo\end{tabular} \\ \hline
		\textbf{Permisson} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Possui todas as permissões \\ existentes (escrita, leitura,\\  delete...)\end{tabular} \\ \hline
		\textbf{GroupPermisson} & id (auto-incrementado) & group\_id permission\_id & \begin{tabular}[c]{@{}l@{}}Associa a cada groupo \\ determinadas permissões\end{tabular} \\ \hline
		\textbf{UserPerCompany} & id (auto-incrementado) & company\_id general\_user\_id & \begin{tabular}[c]{@{}l@{}}Associa cada general user\\  a um company user\end{tabular} \\ \hline
		\textbf{CommunicationType} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos tipos \\ de comunicação inseridos \\ no sistema\end{tabular} \\ \hline
		\textbf{ControllerModule} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos \\ controller module \\ inseridos no sistema\end{tabular} \\ \hline
	\end{tabular}
	\caption{My caption}
\end{table}


\newpage




\begin{table}[]
	\centering

	\label{tabeladb2}
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|l|l|}
		\hline
		\multicolumn{1}{|c|}{\cellcolor[HTML]{EFEFEF}\textbf{Nome da tabela}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Chave primária (PK)}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Chave estrangeira (FK)}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Descrição}} \\ \hline
		\textbf{CMPerCompany} & id (auto-incrementado) & \begin{tabular}[c]{@{}l@{}}cm\_id\\ company\_id\end{tabular} & \begin{tabular}[c]{@{}l@{}}Associa todos os controller module\\  a um determinado company user\end{tabular} \\ \hline
		\textbf{SensorModule} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos sensor \\ module inseridos no sistema\end{tabular} \\ \hline
		\textbf{SMperCM} & id (auto-incrementado) & \begin{tabular}[c]{@{}l@{}}cm\_id\\ sm\_id\end{tabular} & \begin{tabular}[c]{@{}l@{}}Associa os sensor modules a \\ um determinado controller module\end{tabular} \\ \hline
		\textbf{CommunicationTypePerSM} & id (auto-incrementado) & \begin{tabular}[c]{@{}l@{}}communication\_type\_id\\ \\ sm\_id\end{tabular} & \begin{tabular}[c]{@{}l@{}}Permite associar a um sensor \\ module um ou várias tipos \\ de comunicação\end{tabular} \\ \hline
		\textbf{SensorType} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos tipos \\ de sensores inseridos no sistema\end{tabular} \\ \hline
		\textbf{Sensor} & id (auto-incrementado) & \begin{tabular}[c]{@{}l@{}}sensor\_type\_id\\ sm\_id\end{tabular} & \begin{tabular}[c]{@{}l@{}}Permite identificar um \\ determinado sensor\end{tabular} \\ \hline
		\textbf{AlarmsSettings} & id (auto-incrementado) & sensor\_id & \begin{tabular}[c]{@{}l@{}}Permite guardar as configurações \\ para um determinado sensor\\ (max,min…)\end{tabular} \\ \hline
		\textbf{Reading} & id (auto-incrementado) & sensor\_id & \begin{tabular}[c]{@{}l@{}}Permite guardar as leituras de \\ um determinado sensor\end{tabular} \\ \hline
		\textbf{Alarms} & id (auto-incrementado) & reading\_id & \begin{tabular}[c]{@{}l@{}}Armazena os alarmes \\ que são gerados\end{tabular} \\ \hline
	\end{tabular}
	\caption{My caption}
\end{table}

\end{landscape}



\newpage
\section{Arquitetura lógica}

Nesta secção é apresentada uma arquitetura lógica do sistema, indicando as camadas que este deverá conter, especificando quais as relações de dependência que estas possuem entre si. Seguidamente, é explicado como implementar esta lógica com os respetivos componentes físicos. 


Normalmente este tipo de arquitetura é composto por três camadas com intenções diferentes: camada de apresentação, camada de lógica de negócio e camada de acesso a dados. Pretende-se que com a descrição desta arquitetura seja facilitada a manutenção, a portabilidade e a
escalabilidade, fatores importantes quando queremos partilhar funcionalidades e informação entre aplicações de diferentes tipos.




\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/arquitetura-logica.pdf}
	\caption{Arquitetura lógica}
	\label{opencvlogo}
\end{figure}



\subsection{Camada de apresentação}


A camada de apresentação é responsável pela comunicação entre os utilizadores e a aplicação, sendo ela web ou mobile, exibindo informações aos utilizadores, abrangendo uma interface que permite solicitações ao sistema. Esta camada tem uma relação de dependência com a camada de lógica de negócio e tira partido do acesso a serviços de informação externos, que fornecem diversas funcionalidades. 


A interface do utilizador foi desenvolvida em  \ac{HTML} e \acs{CSS}, fazendo uso de jQuery e Javascript.



\begin{itemize}
	\item \ac{HTML} é a linguagem padrão usada para estruturar e apresentar conteúdos na web. Neste caso, foi utilizado HTML5, a quinta versão do \ac{HTML}.
	\item \ac{CSS} é uma linguagem usada para descrever a apresentação de conteúdo escrito em uma marcação Como HTML.
	
	\item Javascript é a linguagem de programação para páginas da web.
	\item \textbf{JQuery}: JQuery é uma biblioteca Javascript que simplifica a programação Javascript
\end{itemize}









\subsection{Camada de lógica de negócio}



\subsection{Camada de acesso a dados}


Nesta camada deverão estar presentes as funcionalidades de criação, edição, remoção ou simples de visualização dos dados, sendo responsável pelas operações
de persistência e consulta de dados solicitadas pela camada de lógica de negócio.




\newpage
\section{Arquitetura física}


Enquanto que a arquitetura lógica se concentra nos diferentes níveis de abstração do sistema, por outro lado a arquitetura física foca-se na estrutura de alto nível.  
Seguidamente são apresentados todos os componentes físicos, tanto  a nivel de software com de hardware, que são fundamentais ao bom funcionamento de todo o sistema. 
A figura X representa genericamente os blocos principais do sistema proposto que seguidamente serão descritos. 


\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{esquemas/esquema-blocos.pdf}
	\caption{Arquitetura lógica}
	\label{opencvlogo}
\end{figure}


  
\subsection{Sistema de informação}



\subsubsection{\ac{API}}

Os métodos da API permitem executar as funções REST. Assim, torna-se fundamental perceber estes métodos para ter um melhor conhecimento do funcionamento do sistema. Como tal, de seguida, são descritos os métodos mais importantes que dão suporte a cada uma das funções REST.

\begin{itemize}
	\item \textbf{GET}: 
	\item \textbf{POST}: 
	\item \textbf{PUT}: 
	\item \textbf{DELETE}: 
\end{itemize}






Autenticação

Documentação automática



%\section{Documentação automática}

%\subsection{Documentação API}

utilizado swagger; apenas permite acesso a quem está logado... incorporar layout do swagger com o do salidashboard




\newpage




\subsubsection{Aplicação web}

\subsubsection{Aplicação mobile}




\newpage
\subsection{Simulação em hardware}

Para o cenário anteriormente descrito foram utilizados dois micro-controladores bastante comuns no mercado: um Arduino Nano e um Raspberry Pi 3. Neste contexto, assume-se que o Arduino Nano é considerado um \ac{SM} que possui um conjunto de sensores enquanto que o Raspberry Pi 3 é um \ac{CM} que recebe os dados provenientes do \ac{SM} enviando-os para o servidor. 


--

Após a desenvolvimento da API descrita no capitulo anterior, pretendeu-se simular o sistema num contexto real. Para tal, planeou-se encontrar hardware que encaixasse no contexto deste projeto. Foram utilizados dois micro-controladores e alguns sensores. Neste capitulo será descrito cada um deles e o processo de desenvolvimento da respetiva simulação.  

\newpage

\subsubsection{Sensores utilizados}

Nesta secção serão apresentados os sensores utilizados na simulação e as suas principais características. Todos os sensores foram escolhidos tendo em conta o seu enquadramento no projeto e a sua disponibilidade no laboratório. Todos os sensores que se apresentam encontram-se ligados a um Arduino nano. \\


\textbf{Temperatura}


Como sensor de temperatura foi utilizado um termístor do tipo \ac{NTC}. Como vimo anteriormente, um termístor é um semicondutor sensível à temperatura i.e. cujo o coeficiente de variação da resistência com a temperatura é negativa, ou seja, quando a temperatura sobe então consequentemente a resistência diminui. 

Na figura \ref{esquema-temp} encontra-se o esquema de ligação deste componente e na tabela \ref{table-temp} as propriedades principais. 

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/temperatura.jpg}
		\caption{TTC 104 NTC}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/temp-esquema.pdf}
		\caption{Esquema eletrotécnico da ligação do sensor de temperatura}
		\label{esquema-temp}
	\end{minipage}
\end{figure}



\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{C0C0C0}}l |l|} \hline
		Dimensão & 5mm \\ \hline
		Resistência & 100K $\Omega$  \\ \hline
		Valor máximo & +125C \\ \hline
		Valor mínimo & -30C \\ \hline
		Nível de confiança & + - 10\% \\ \hline
		Preço & 0.35 \euro/unidade \\ \hline
	\end{tabular}
	\caption[Características do sensor TTC 104]{Características do sensor TTC 104 \cite{temp-dta}}
	\label{table-temp}
\end{table}


\newpage
\textbf{Luminosidade}

Para simular a luminosidade incidente foi utilizado um sensor do tipo foto-resistência. Este sensor, também conhecido como \ac{LDR}, não é mais do que uma resistência variável cujo o seu valor varia conforme a intensidade da luz que incide sobre ele i.e. à medida que a intensidade da luz aumenta, a sua resistência diminui. Este sensor tem múltiplas aplicações, entre as quais se destaca a monitorização solar, indicador da posição do sol (up/down), alarmes anti-roubo, alarme para abertura/fecho de portas entre outras. 

Como vimos na secção X do capitulo do Estado de Arte é um sensor de baixo custo e bastante fácil de utilização. Na figura \ref{lum-esquema} encontra-se o esquema de ligação do componente e na tabela \ref{lum-cara} são apresentadas as principais características do sensor utilizado. 







\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/luminosidade.png}
		\caption{Sensor foto-resistência GL5528}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/lumi_esquema.pdf}
		\caption{Esquema eletrotécnico da ligação do sensor de luminosidade}
		\label{lum-esquema}
	\end{minipage}
\end{figure}











\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{C0C0C0}}l |l|} \hline
		Diâmetro & 5mm \\ \hline
		Tensão máxima & 150VDC \\ \hline
		Potência máxima & 100mW \\ \hline
		Tensão de operação & -30 C a 70 C \\ \hline
		Espectro &540nm \\ \hline
		Comprimento com terminais & 32mm \\ \hline
		Resistência no escuro &1 M (Lux 0) \\ \hline
		Resistência na luz &10-20 Komega (Lux 10) \\ \hline
		Material & Carbono \\ \hline
		Preço & 0.22 \euro/unidade \\ \hline
	\end{tabular}
	\caption[Características do sensor GL5528]{Características do sensor GL5528 \cite{lum-data}}
	\label{lum-cara}
\end{table}


\newpage

\textbf{Sensor de nível líquido}

Este sensor não é mais do que um interruptor que é ativo sempre que um determinado líquido ultrapassa o mesmo. Sempre que algum líquido atingir o pedaço de plástico este irá subir ativando assim o circuito. 
Na figura \ref{esquem-liquido} encontra-se o esquema da ligação deste sensor.




\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/liquido.JPG}
		\caption{\textit{Water Level Switch Liquid Level Sensor Plastic Ball Float}}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/sw_esquema.pdf}
		\caption{Esquema eletrotécnico da ligação do sensor de nível líquido}
		\label{esquem-liquido}
	\end{minipage}
\end{figure}



\textbf{Simulador de válvula para transferências de águas}

Para a simulação de uma válvula que permitirá as transferência de água doce e salgada foi utilizado um simples \textit{led}. Este possibilita facilmente identificar através da ativação do \textit{led} se a válvula se encontra ativa ou não. 


\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/led.jpg}
		\caption{Led simples.}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/led_esquema.pdf}
		\caption{Esquema eletrotécnico da ligação do led}
	\end{minipage}
\end{figure}




\newpage
\subsubsection{Comunicação}

Nesta secção, será apresentado o tipo de comunicação para este cenário de simulação. Pretendeu-se que cada um dos módulo ficassem isolados entre si, o que implicou o estudo e respetiva escolha de algumas tecnologias de comunicações sem fio. Neste caso, foram escolhidas as seguintes: 

\begin{itemize}
	\item \textbf{Bluetooth}: utilizado para a comunicação entre o Arduino (\ac{SM}) e o Raspberry Pi 3 (\ac{CM}). No Arduino foi utilizado um módulo Bluetooth HC-06 e no Raspberry Pi 3 foi utilizado o seu próprio módulo interno. 
	\item \textbf{Wifi}: utilizado para a comunicação entre o Raspberry Pi 3 (\ac{CM}) e o servidor. 
\end{itemize}


O esquema da figura \ref{esquemcomm} pretende esquematizar os tipos de comunicação envolvidos nesta simulação para cada um dos componentes. 

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{img/comm-blue/HW-geral.pdf}
	\caption{Arquitetura lógica}
	\label{esquemcomm}
\end{figure}




Módulo bluetooth HC-06



Este módulo bluetooth HC-05 oferece uma forma fácil e barata de comunicação com seu projeto Arduino. Diferente do modelo HC-06, suporta tanto o modo mestre como escravo, além de ter uma fácil configuração.

Em sua placa existe um regulador de tensão e você poderá alimentar com 3.3 a 5v, bem como um LED que indica se o módulo está pareado com outro dispositivo. Possui alcance de até 10m.

é mais uma forma simples e barata de enviar e receber informações remotamente.


\newpage
\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/hardware/bluetooth_zs-040.png}
		\caption{Flower one.}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.4\textwidth}
		\includegraphics[width=\textwidth]{img/comm-blue/electronic-sensors.pdf}
		\caption{Esquema eletrotécnico da ligação do módulo bluetooth}
	\end{minipage}
\end{figure}



\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{C0C0C0}}l |l|} \hline
		Diâmetro & 5mm \\ \hline
		
		Protocolo Bluetooth& v2.0+EDR \\ \hline 
		Frequência& 2,4GHz Banda ISM \\ \hline
		Segurança& Autentificação e Encriptação \\ \hline
		Tensão& 3,3v (2,7-4.2v) \\ \hline
		Alcance& 10m \\ \hline
		Dimensões& 26,9 x 13 x 2,2mm \\ \hline
		Peso& 9,6g \\ \hline
		Preço&32\euro /unidade  \\ \hline
	\end{tabular}
	\caption[Características do sensor GL5528]{Características do sensor GL5528 \cite{lum-data}}
	\label{lum-cara}
\end{table}



%http://www.instructables.com/id/Modifying-the-AT-Codes-on-a-HC-05-With-the-Code-ZS/


%http://www.arduinoecia.com.br/2013/03/modulo-bluetooth-jy-mcu-configuracao.html








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Diagrama de componentes}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/database_tese.pdf}
	\caption{Esquema relacional da estrutura da base de dados}
	\label{esquemarelacional}
\end{figure}








\newpage








\section{Considerações finais}