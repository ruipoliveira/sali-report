

\chapter{Sistema de controlo e monitorização: arquitetura e modelação}



%Dashboard - 


% Mockups - Design que a plataforma deverá apresentar no fim do seu desenvolvimento.


%\section{title}



Segundo \textit{Laudon et al.}\cite{Laudon1998}, um sistema de informação define-se como sendo uma inter-relação de múltiplos componentes podendo estes ser equipamentos, telecomunicações, \textit{software}, bases de dados e outras tecnologias de transformação de informação. Todos estes componentes permitem a recolha, processamento, armazenamento e distribuição de informação que possibilita a tomada de decisões e controlo para uma determinada organização, ou até mesmo para a sociedade, de modo a torná-la mais acessível e útil.

Dada a elevada complexidade de um sistema de informação, é possível identificar algumas funcionalidades comuns aos diversos sistema existentes, são elas\cite{Turban1996}: 

\begin{itemize}
	\item \textbf{Recolha de dados}: sequência de tarefas que possibilitam a adição de novos dados ao sistema;
	
	\item \textbf{Organização e armazenamento de dados}: é imprescindível uma boa organização da estrutura de dados para fácil e rápida localização;
	
	\item \textbf{Processamento de dados}: qualquer funcionalidade que permita a produção de resultados mais úteis do que os dados em bruto; 
	
	\item \textbf{Distribuição de informação}: após o processamento de dados é fundamental a distribuição destes a quem precise deles; 
	
	\item \textbf{Utilização da informação}: por si só, a informação não tem qualquer valor, a sua utilização em contexto adequado possibilita a extração de determinadas conclusões para que possam ser tomadas decisões.
	
\end{itemize}


Este capítulo tem como principal objetivo a descrição do sistema de informação que resultou do trabalho prático desta dissertação. Cada elemento do sistema é caracterizado de acordo com as suas funções, especificidades e arquitetura, bem como a forma como os elementos interagem entre si. Para além disso, é apresentado todo o processo de modelação do sistema tendo por base os requisitos do cliente que de seguida se descrevem.


\section{Análise de requisitos}
\label{sect:analise}


%http://www.sersc.org/journals/IJSEIA/vol8_no3_2014/38.pdf

Antes de entender a descrição geral do sistema e os componentes envolvidos, foi realizado um levantamento do requisitos do sistema, levando-nos a entender o que o cliente pretende. Os requisitos funcionais e não funcionais deste sistema, que serão apresentados de seguida, permitem a criação dos processos de negócio. 


 Relativamente à metodologia apresenta na secção \ref{method}, esta etapa refere-se às duas primeiras fases: Análise da viabilidade e Análise e especificação de requisitos. 


\subsection{Requisitos funcionais}


Os requisitos funcionais descrevem os critérios que devem ser usados para avaliar as funções específicas ou os comportamentos de um determinado sistema. Os requisitos funcionais que de seguida se apresentam foram propostos pelos clientes (empresa/investigadores) no contexto deste projeto para as duas plataformas disponíveis: \textit{web} (\textit{dashboard}) e \textit{mobile}. \\


\textbf{Aplicação web (\textit{dashboard})}


\begin{itemize}
	\item A interface do sistema deve permitir que o utilizador, seja ele qual for, entre ou faça \textit{login} no sistema;
	
	\item A interface do sistema deve permitir que o utilizador, seja ele qual for, saia ou faça \textit{logout} no sistema;
	
	\item O \textit{dashboard} deverá permitir que qualquer utilizador possa recuperar a sua chave de acesso ao sistema (\textit{password});
	
	\item O sistema deve permitir que o utilizador possa adicionar e/ou gerir um ou vários módulos de sensores; 
	
	\item A aplicação \textit{web} deve permitir visualizar graficamente os dados que cada sensor obtém; 
	
	\item O sistema deve permitir visualizar tabularmente (\textit{dataset}) os dados que cada sensor obtém;  
	
	\item Em cada uma das visualizações anteriormente descritas, deve ser possível efetuar uma filtragem por data;
	
	\item O sistema deverá permitir a exportação dos dados obtidos pelos sensores  em formato \ac{CSV}; 
	
	\item O sistema deve ter a capacidade de gerar alarmes quando algum valor lido pelos sensores esteja fora do previsto.
	
\end{itemize}


De modo a tornar o sistema genérico foram impostos os seguintes requisitos adicionais: 


\begin{itemize}
	\item O sistema deve permitir que qualquer utilizador se possa registar no sistema, embora tenha que estar obrigatoriamente associado a uma empresa;
	
	\item O utilizador comum só terá acesso à sua área reserva após a validação por parte da empresa;
	
	\item A \textit{dashboard} deverá permitir ao administrador a adição de novas empresas e a gestão de todos os utilizadores;
	
	
	\item O sistema deve permitir que qualquer utilizador possa adicionar, editar ou remover: 
	\begin{itemize}
		\item Tipos de sensores; 
		
		\item Tipos de comunicação;
		
		
		%\item \acl{CM} com as respetivas especificações e características;
		
		%\item Tipo de comunicação a um \acl{CM} que possibilite a sua comunicação como o servidor; 
		
		%\item  \textit{Sensor Modules} a um determinado \acl{CM} com as suas respetivas especificações e características; 
		
		%\item Um ou vários tipos de comunicação a um \acl{SM} que permita a sua comunicação com um \acl{CM}; 
		
		
		%\item Um ou vários sensores a um \acl{SM} em que cada sensor poderá ser de um determinado tipo.
	\end{itemize}
	
	
	\item O sistema deverá disponibilizar uma \ac{API} que permita a criação de novas aplicações com base nesta;
	
	\item Consultar a documentação da \ac{API} de modo interativo;
	
	\item Gerar e consultar  \textit{token} de autenticação para utilização da \ac{API};
	
	\item Alterar configurações base do utilizador (primeiro nome, último nome, email, etc.).
	
\end{itemize}



\textbf{Aplicação \textit{mobile}}



\begin{itemize}
	\item A interface da aplicação \textit{mobile} deve permitir que o utilizador, seja ele qual for, entre ou faça \textit{login} no sistema; 
	
	\item A interface da aplicação \textit{mobile} deve permitir que o utilizador, seja ele qual for, saia ou faça \textit{logout} no sistema;
	
	
	\item A aplicação \textit{mobile} deve permitir visualizar graficamente os dados de cada sensor, sendo possível filtrá-los por data;
	
	\item  A aplicação deve permitir receber alarmes quando um determinado valor lido pelo sensor esteja fora do pretendido.
	
	
\end{itemize}



\subsection{Requisitos não funcionais}


Os requisitos não funcionais são todos os requisitos da aplicação relacionados com performance, escalabilidade, segurança, disponibilidade e usabilidade. Estes não são necessariamente requeridos pelo cliente. 


\begin{itemize}
	\item O sistema deverá executar em qualquer plataforma, tanto \textit{web} como \textit{mobile}. No caso de aplicação \textit{mobile} pretende-se que esta seja executada em iOS e Android;  
	
	
	\item A base de dados deve ser protegida para acesso apenas a utilizadores autorizados; 
	
	
	\item O sistema deverá disponibilizar uma \ac{API} para que possam ser criados novos produtos com base neste;  
	
	\item Deverá ser usada, na medida do possível, tecnologias sem qualquer custo para o cliente (\textit{open-source}); 
	
	\item Pretende-se que o sistema possa ser adaptado a qualquer outro contexto, não sendo especificamente restrito ao contexto da produção da Salicórnia.  
	
\end{itemize}




\section{Descrição global do sistema}

Este sistema tem como objetivo a supervisão remota da produção de Salicórnia, permitindo não só a monitorização dos dados adquiridos pelos sensores, como também da atuação remota de determinados comandos. Neste contexto, também é possível a aquisição de imagens que possibilitam a deteção de intrusos nas quintas onde se realiza a produção desta espécie. O esquema da figura \ref{componentesalla} ilustra, de um modo geral, todos os componentes e as diferentes plataformas com que o cliente pode interagir. 


\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/global_arquitetura.pdf}
	\caption{Ilustração dos principais componentes do sistema}
	\label{componentesalla}
\end{figure}






Como vimos no capítulo 3, uma plantação de  Salicórnia carece de um controlo relativamente fino de certos parâmetros ambientais sobretudo da salinidade do terreno, que depende, das chuvas, da salinidade da água dos canais da ria, entre outros. Nas quintas onde se cultiva Salicórnia, a produção faz-se numa espécie de leiras limitadas por pequenos canais de irrigação que podem ser cheios de água salgada proveniente dos esteiros que rodeiam a quinta. Esta operação implica a abertura de válvulas de admissão de água, medir o nível da maré nos canais e monitorizar a qualidade e salinidade da água exterior.



\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/leiras-comm-geral.pdf}
	\caption{Ilustração da distribuição dos módulos em duas leiras}
	\label{leira}
\end{figure}


Tal como ilustrado na figura \ref{leira}, foram colocados módulos com sensores (SM) distribuídos estrategicamente por cada leira. Cada um desses módulos, irá comunicar com um módulo central (CM) originando uma topologia de rede em estrela.  Por sua vez, cada um destes módulos centrais irá comunicar diretamente com o servidor que receberá todos os dados adquiridos tanto pelos sensores como por atuadores, permitindo que estes sejam guardados numa base de dados específica. Os atuadores, permitirão despoletar ações que autorizam a ativação ou desativação de bombas e/ou válvulas para transferências de água de modo a melhorar as condições de cultivo da Salicórnia. 
Os módulos centrais têm acesso à camada protocolar \ac{TCP}/\ac{IP} (Internet) para possibilitar a utilização da \acs{API} \acs{REST} desenvolvida para o efeito. 

No que diz respeito às plataformas de interação com o cliente, existe uma \textit{dashboard} (plataforma \textit{web}) e a planificação de uma aplicação \textit{mobile}. A \textit{dashboard} disponibiliza uma interface que apresenta as informações mais importantes para o utilizador de forma apelativa, tornando mais fácil a sua interação e respetiva leitura, possibilitando ainda a gestão de todo o sistema e realização de operações de controlo remoto. Por outro lado, a aplicação \textit{mobile} permite apenas a monitorização do cultivo da Salicórnia e a receção de alertas quando estes surgirem.




\subsection{Componentes}

No contexto desta dissertação é necessário reter dois conceitos principais, são eles: 

\begin{itemize}
	\item \textbf{\acl{SM} (SM):} consiste num módulo responsável pela aquisição de dados provenientes dos mais diversos tipos de sensores; 
	
	
	\item \textbf{\acl{CM} (CM):} consiste num módulo responsável pela receção dos dados/estados dos sensores do \acl{SM} e respetivo envio para a \textit{cloud}.  
	
\end{itemize}


\begin{figure}[h]
	\centering
	\includegraphics[width=0.95\linewidth]{esquemas/general-electronic-modules.pdf}
	\caption{Esquema de componentes e respetiva comunicação entre três \ac{SM} e um \ac{CM}}
	\label{esquema1}
\end{figure}

O cenário da figura \ref{esquema1} ilustra três \textit{Sensor Modules} que comunicam com um \acl{CM}. Cada um desses \acl{SM} possui um conjunto específico de sensores, podendo estes ser atuadores ou câmaras. Para a comunicação com o \acl{CM}, cada \acl{SM} possui um determinado módulo de comunicação que permite a transferência dos dados adquiridos pelos sensores. Posteriormente, o \acl{CM} possui também um determinado módulo de comunicação (\acs{TCP}/\acs{IP}) que permite a utilização da \ac{API} e respetivo envio ou atualização dos dados adquiridos pelo sistema. 





Seguidamente serão especificados todos os detalhes de cada módulo, uma vez que serão considerados na modelação de todo o sistema. 



\subsubsection{\acl{SM}}



Um \acl{SM} consiste num microcontrolador responsável pela aquisição de dados provenientes dos mais diversos tipos de sensores, podendo estes ser atuadores ou câmaras. No caso de se tratar de um atuador, isto é, válvulas, bombas, contadores, pás ou cancelas, apenas serão lidos valores binários. Caso se trate de uma câmara, todo o processamento é feito internamente nesta, sendo que o sistema apenas irá receber o \ac{IP} da câmara ou um \ac{URL} para um servidor de \ac{RTMP}.  


Tal como referido anteriormente, cada \acl{SM} terá que utilizar um determinado módulo de comunicação para possibilitar a transferência dos dados adquiridos para o módulo central. Para além disso, pretende-se que o \acl{SM} em condições extremas, possa tomar decisões de atuação, isto é, caso seja lido um valor fora do padrão e que seja necessário a ativação de um atuador, este deverá ser auto suficiente em tomar esta decisão, sem necessidade de intervenção do utilizador. 

Pretende-se que este módulo seja identificado por um determinado nome, possua uma bateria que permita a sua mobilidade, tenha um ou vários módulos de comunicação acoplados que permitam comunicar com um módulo centrar. Tenha uma determinada memória e um módulo \ac{GPS} que permita aceder à sua localização, identificando-o em caso de furto. Para além disso, um \acl{SM} terá que possuir obrigatoriamente um ou vários sensores.








\subsubsection{\acl{CM}}



Um \acl{CM} consiste num microcontrolador responsável pela receção dos dados prevenientes dos vários \textit{Sensor Modules}. Pretende-se que este módulo envie ou receba informações para os \acl{SM} quando solicitados pelo utilizador. Após a receção dos dados, estes são enviados para um servidor em \textit{cloud} através de uma \ac{API} criada para o efeito. Como a tecnologia \ac{REST} opera sob o protocolo de comunicação \ac{HTTP}, este componente tem que necessariamente estar ligado à rede Internet (\ac{TCP}/\ac{IP}). 

É essencial que este módulo possua alguma capacidade de processamento, uma vez que poderá ter vários \textit{Sensor Modules} a si associados e com necessidade de constante envio e receção de dados.  Para além disso, pretende-se que o \acl{CM} seja identificado por um determinado nome, tenha um  módulo de comunicação que possibilite o envio de dados para um servidor e outros para comunicação com os diferentes \textit{Sensor Modules}. Tal como acontece com os \textit{Sensor Modules}, existe necessidade de acoplar um módulo \ac{GPS} que permita localizar o microcontrolador em caso de roubo.
 






%\section{Design funcional}







\section{Modelação}

Tal como vimos no início da secção \ref{sect:analise}, a conceção de uma arquitetura envolve o estudo e respetiva modelação dos componentes de \textit{software} e \textit{hardware} que são fundamentais para a realização da mesma, bem como a análise dos casos de uso e respetiva especificação, criação do modelo de dados, diagramas de fluxos, entre outros. Toda esta modelação será descrita nesta secção permitindo entender melhor como emparelhar toda a estrutura pretendida. Relativamente à metodologia apresenta na secção \ref{method}, esta etapa refere-se à fase de \textit{Designing} (figura \ref{sdlcartic}). 






\subsection{Entidades envolvidas}

As entidades envolvidas ou atores são os utilizadores do sistema, podendo ser humanos ou máquinas, que interagem com o sistema para executar uma determinada ação significativa. No contexto do sistema descrito, existem três entidades distintas que são importantes descrever: 

\begin{itemize}
	
	\item \textbf{\textit{General user}}: este ator poderá registar-se e associar-se a uma determinada empresa existente no sistema. Após a validação por parte da empresa, este utilizador poderá aceder à sua área reservada através da \textit{dashboard} ou da aplicação \textit{mobile}. 
	
	\item \textbf{\textit{Company user}}: este utilizador tem a possibilidade de gerir todos os \textit{general users} que se possam associar à sua empresa. Deste modo, este utilizador poderá validar ou remover os \textit{general users} que a si se associam. 
	
	\item \textbf{Administrador}: vulgarmente denominado por \textit{admin}. Pretende-se que apenas exista um único administrador. Este ator tem a possibilidade de adicionar novas empresas ao sistema, isto é, criar novos utilizadores com permissões específicas. 
	
\end{itemize}




\subsection{Casos de uso}

Nas figuras \ref{usedash} e \ref{useMobile} encontram-se representados os esquemas dos casos de uso da \textit{dashboard} e da aplicação \textit{mobile}, respetivamente.
Seguidamente serão descritos cada um dos casos de uso para as duas plataformas. De notar que todos os casos de uso na aplicação \textit{mobile} também se encontram disponíveis através da \textit{dashboard}. 



\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.85\linewidth]{esquemas/use-case-web.pdf}
	\caption{Casos de uso para a aplicação \textit{web} (\textit{dashboard}) }
	\label{usedash}
\end{figure}


\newpage


\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.85\linewidth]{esquemas/use-case-mobile.pdf}
	\caption{Casos de uso para a aplicação \textit{mobile}}
	\label{useMobile}
\end{figure}





\begin{itemize}
	\item \textbf{Login no sistema}: qualquer utilizador (\textit{general user}, \textit{company user} ou \textit{admin}) poderá aceder ao sistema tendo para isso que possuir uma conta registada e validada no caso de ser um \textit{general user}. Após a validação das suas credenciais (\textit{username} e \textit{password}) o utilizador poderá aceder à página inicial da \textit{dashboard} e a todo o seu conteúdo. Este caso de uso encontra-se disponível para os dois tipos de plataformas; 
	
	
	\item \textbf{Logout no sistema}: qualquer utilizador (\textit{general user}, \textit{company user} ou \textit{admin}) poderá sair do sistema tendo que para isso que estar obrigatoriamente logado no sistema. Após o \textit{logout} ser-lhe-á apresentada novamente a página de \textit{login}. Este caso de uso encontra-se disponível para os dois tipos de plataformas; 
	
	
	\item \textbf{Recuperar \textit{password}}: qualquer utilizador (\textit{general user}, \textit{company user} ou \textit{admin}) poderá recuperar a sua \textit{password} de acesso ao sistema. Para isso, terá que introduzir o seu email e posteriormente ser-lhe-á enviado o acesso que possibilita a redefinição da \textit{password}; 
	
	
	
	\item \textbf{Adicionar, editar, remover tipos de comunicação}: qualquer \textit{general user} ou \textit{company user} poderá adicionar, editar ou remover os tipos de comunicação existentes no sistema. Ao  adicionar, o utilizador terá que introduzir um nome, um caminho relevante para o tipo de comunicação e selecionar um icon ilustrativo. No caso da remoção, esta ação apenas é possível se o tipo de comunicação não se encontrar em utilização por nenhum \acl{CM} ou \acl{SM};  
	
	\item \textbf{Adicionar, editar, remover tipos de sensores}: qualquer \textit{general user} ou \textit{company user} poderá adicionar, editar ou remover os tipos de sensores existentes no sistema. Ao  adicionar, o utilizador terá que introduzir um nome que o identifique, uma fonte de dados ou a escala dos mesmos e um icon que identifique o sensor. Para além disso, o utilizador terá que escolher uma cor que identifique o tipo de sensor na \textit{dashboard}. No caso da remoção, esta ação apenas é possível se o tipo de sensor não se encontrar em utilização por nenhum \acl{SM};   
	 
	
	\item \textbf{Adicionar, editar, remover um \acl{CM}}: qualquer \textit{general user} ou \textit{company user} poderá adicionar, editar ou remover um \acl{CM} existente no sistema. Neste caso, pressupõe-se que o utilizador possua um microcontrolador com as seguintes características que serão  adicionadas: nome para identificação, valor da memória \ac{RAM} em MBytes, estado inicial (ativo ou desativo) e um módulo de comunicação que permita comunicar com o servidor. Estas características são possíveis de  alteração. Pretende-se que um \acl{CM} possa ser removido tendo \textit{Sensor Modules} a ele associado, sendo estes também removidos automaticamente do sistema;


	\item \textbf{Adicionar, editar, remover um \acl{SM}}: qualquer \textit{general user} ou \textit{company user} poderá adicionar, editar ou remover um \acl{SM} existente no sistema. Pressupõe-se que o utilizador possua um determinado microcontrolador com um ou mais sensores. Para adicionar o \acl{SM} à plataforma o utilizador terá que atribuir um nome que o identifique, definir qual o seu estado inicial (ativo ou desativo), escolher os tipos de comunicação presentes e definir o intervalo de tempo para o qual pretende receber os dados lidos pelos sensores. Para além disso, permite associar ao \acl{SM} os sensores presentes e definir o valor máximo e mínimo para os quais são gerados alarmes e respetivas mensagens para notificação. Todos estes dados são possíveis de edição; 
	

	
	\item \textbf{Receber notificações (gerar alarmes)}: sempre que um valor lido por um determinado sensor sai fora dos limites impostos, isto é do valor máximo e do valor mínimo, é gerado um alarme para o utilizador de modo a que este possa intervir. Este caso de uso encontra-se disponível para os dois tipos de plataformas;
	
	
	\item \textbf{Visualizar graficamente os dados lidos pelos sensores}: o utilizador poderá interagir com as duas plataformas a fim de visualizar graficamente os dados lidos pelos diferentes tipos de sensores existentes, tendo a possibilidade de selecionar as datas de início e fim da consulta. Para além disso, poderá guardar os gráficos em diferentes formatos de imagem;
	
	\item \textbf{Visualizar tabularmente os dados lidos pelos sensor}: analogamente ao caso de uso anterior, o utilizador poderá neste caso visualizar tabularmente os dados obtidos, tendo também a possibilidade de filtrar os dados disponíveis por data; 
	
	\item \textbf{Exportar dados lidos de um \acl{SM}}: qualquer \textit{general user} ou \textit{company user} poderá exportar os dados lido pelos sensores, numa data específica, para um ficheiro do tipo \ac{CSV}; 
	
	\item \textbf{Visualizar a localização dos módulos (\acl{SM}/\acl{CM})}: qualquer \textit{general user} ou \textit{company user} ao aceder à \textit{dashboard} ser-lhe-à apresentado um mapa para cada \acl{CM} com a sua localização e dos seus respetivos \textit{Sensor Modules}; 
	
	
	\item \textbf{Consultar a documentação da API}: qualquer \textit{general user} ou \textit{company user} poderá aceder à \textit{dashboard} para consultar a documentação iterativa da \ac{API} existente; 
		
	\item \textbf{Consultar \textit{token} de autenticação}: qualquer \textit{general user} ou \textit{company user} poderá aceder ao \textit{token} de autenticação para utilização da \ac{API}; 
	

	
	\item \textbf{Validar \textit{general user}}: qualquer \textit{company user} tem a possibilidade de validar os \textit{general users} que a si se associam. Sempre que um novo \textit{general user} é registado no sistema o \textit{company user} é notificado via email. Posteriormente, caso o \textit{general user} seja validado este também receberá um email de confirmação;  
	
	\item \textbf{Remover \textit{general user}}: qualquer \textit{company user} tem a possibilidade de remover os \textit{general users} a si associados; 
	
	
	\item \textbf{Remover \textit{Sensor Modules} e \textit{Controller Modules} }: o \textit{admin} do sistema tem a possibilidade de remover os \textit{Sensor Modules} e/ou \textit{Controller Modules} existentes no sistema; 
	
	
	\item \textbf{Visualizar todos os \textit{Sensor Modules} e \textit{Controller Modules}}: o \textit{admim} do sistema tem a possibilidade de visualizar todos os \textit{Sensor Modules} e \textit{Controller Modules} existentes no sistema de modo a alertar os clientes em caso de anomalias;
	
	
	\item \textbf{Criar um novo \textit{company user}}: o \textit{admim} tem a possibilidade de adicionar novos \textit{company user} ao sistema; 
	
	\item \textbf{Remover um \textit{company use}r}: o \textit{admim} tem a possibilidade de remover qualquer \textit{company user} registado no sistema.
	
	
\end{itemize}









\newpage
\subsection{Modelo de dados}
\label{modelocap}

Depois da análise dos requisitos desenhou-se um modelo de dados que permite suportar todo o sistema descrito, obtendo-se assim o esquema relacional apresentado na figura \ref{esquemarelacional}.





\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/database_tese.pdf}
	\caption{Esquema relacional da estrutura da base de dados}
	\label{esquemarelacional}
\end{figure}


Nas tabelas \ref{tabeladb1} e \ref{tabeladb2} são descritas cada uma das entidades de dados existente neste sistema, evidenciando as chaves primárias (\ac{PK}) e estrangeiras (\ac{FK}) de cada uma. 



\newpage
\begin{landscape}
	
	


\begin{table}[]
	\centering

	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|l|l|}
		\hline
		\textbf{Nome da tabela} & \cellcolor[HTML]{EFEFEF}\textbf{Chave primária (PK)} & \cellcolor[HTML]{EFEFEF}\textbf{Chave estrangeira (FK)} & \cellcolor[HTML]{EFEFEF}\textbf{Descrição} \\ \hline
		\textbf{User} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos \\ utilizadores inseridos no sistema\end{tabular} \\ \hline
		\textbf{Token} & \begin{tabular}[c]{@{}l@{}}authtoken\_token\_pkey\\ (character varying(40))\end{tabular} & id\_user & \begin{tabular}[c]{@{}l@{}}Possui o \textit{token} de autenticação\\ do utilizador para a API\end{tabular} \\ \hline
		\textbf{Group} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Possui todos os tipos de grupos\\  existentes: \textit{general user}, \\ \textit{company user} e \textit{admin}\end{tabular} \\ \hline
		\textbf{UserGroups} & id (auto-incrementado) & id\_user, id\_group & \begin{tabular}[c]{@{}l@{}}Permite associar um utilizador\\  a um determinado grupo\end{tabular} \\ \hline
		\textbf{Permisson} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Possui todas as permissões\\  existentes (escrita, leitura,\\  delete...)\end{tabular} \\ \hline
		\textbf{GroupPermisson} & id (auto-incrementado) & id\_group, id\_permission & \begin{tabular}[c]{@{}l@{}}Associa a cada grupo \\ determinadas permissões\end{tabular} \\ \hline
		\textbf{UserPerCompany} & id (auto-incrementado) & id\_company, id\_general\_user & \begin{tabular}[c]{@{}l@{}}Associa cada \textit{general user}\\  a um \textit{company user}\end{tabular} \\ \hline
		\textbf{CommunicationType} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos tipos\\  de comunicação inseridos\\  no sistema\end{tabular} \\ \hline
		\textbf{ControllerModule} & id (auto-incrementado) & id\_communication & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos \\ \textit{controller module}\\  inseridos no sistema\end{tabular} \\ \hline
	\end{tabular}
		\caption{Especificação das tabelas da base de dados existentes no sistema }
		\label{tabeladb1}
\end{table}


\newpage








\begin{table}[]
	\centering
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|l|l|}
		\hline
		\textbf{Nome da tabela} & \cellcolor[HTML]{EFEFEF}\textbf{Chave primária (PK)} & \cellcolor[HTML]{EFEFEF}\textbf{Chave estrangeira (FK)} & \cellcolor[HTML]{EFEFEF}\textbf{Descrição} \\ \hline
		\textbf{CMPerCompany} & N/A & id\_cm, id\_company & \begin{tabular}[c]{@{}l@{}}Associa todos os \textit{Controller Module}\\  a um determinado \textit{company user}\end{tabular} \\ \hline
		\textbf{SensorModule} & id (auto-incrementado) & id\_cm, id\_communication & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos \textit{sensor} \\ \textit{module} inseridos no sistema\end{tabular} \\ \hline
		\textbf{CommunicationTypePerSM} & N/A & id\_communication\_type, id\_sm & \begin{tabular}[c]{@{}l@{}}Permite associar a um \textit{sensor}\\  \textit{module} um ou várias tipos de\\  comunicação\end{tabular} \\ \hline
		\textbf{SensorType} & id (auto-incrementado) & N/A & \begin{tabular}[c]{@{}l@{}}Identifica cada um dos tipos de \\ sensores inseridos no sistema\end{tabular} \\ \hline
		\textbf{Sensor} & id (auto-incrementado) & id\_sensor\_type, id\_sm & \begin{tabular}[c]{@{}l@{}}Permite identificar um \\ determinado sensor\end{tabular} \\ \hline
		\textbf{AlarmsSettings} & id (auto-incrementado) & id\_sensor & \begin{tabular}[c]{@{}l@{}}Permite guardar as configurações \\ para um determinado \\ sensor (max,min…)\end{tabular} \\ \hline
		\textbf{Reading} & id (auto-incrementado) & id\_sensor & \begin{tabular}[c]{@{}l@{}}Permite guardar as \\ leituras de um \\ determinado sensor\end{tabular} \\ \hline
		\textbf{Alarms} & N/A & id\_reading & \begin{tabular}[c]{@{}l@{}}Armazena os alarmes \\ que são gerados\end{tabular} \\ \hline
	\end{tabular}
		\caption{Especificação das tabelas  da base de dados existentes no sistema (continuação) }
		\label{tabeladb2}
\end{table}

\end{landscape}



\newpage
\section{Arquitetura lógica}

Nesta secção é apresentada a arquitetura lógica do sistema, indicando as camadas que contém e especificando quais as relações de dependência que estas possuem entre si. Seguidamente, é explicado como implementar esta lógica com os respetivos componentes físicos. 


Normalmente, este tipo de arquitetura é composto por três camadas (\textit{3 Tier})\cite{Josuttis2001} com funções diferentes: camada de apresentação, camada de lógica de negócio e camada de acesso a dados. Pretende-se que com a descrição desta arquitetura seja facilitada a manutenção, a portabilidade e a
escalabilidade, fatores importantes quando queremos partilhar funcionalidades e informação entre aplicações de diferentes tipos.




\begin{figure}[!htb]
	\centering
	\includegraphics[scale = 0.6]{esquemas/arquitetura-logica.pdf}
	\caption{Esquema representativo da arquitetura lógica do sistema }
	\label{logicaarqu}
\end{figure}



A camada de apresentação é responsável pela comunicação entre os utilizadores e a aplicação, sendo ela \textit{web} ou \textit{mobile}, exibindo informações aos utilizadores, abrangendo uma interface que permite solicitações ao sistema. Esta camada tem uma relação de dependência com a camada de lógica de negócio e tira partido do acesso a serviços de informação externos, que fornecem diversas funcionalidades. A interface do utilizador foi desenvolvida em  \ac{HTML} e \acs{CSS}, fazendo uso de jQuery e \ac{JS}.





A camada de lógica é onde é realizado todo o processamento dos dados adquiridos pelos sensores ou introduzidos pelos utilizadores do sistema através da camada de apresentação.  Tal como apresentado na figura \ref{logicaarqu}, existem quatro sub-camadas principais, que enfatizam os principiais conceitos existentes nesta camada, a seguir descritos.  


\begin{itemize}
	\item \textbf{Gestão de utilizadores}: todas as operações realizadas por cada utilizador devem ser medidas pelas permissões que estes possuem. Nesta camada é verificado se um determinado utilizador viola ou não essas permissões. 
	
	\item \textbf{Geração de alarmes}: todos os alarmes são gerados conforme a verificação automática realizada a cada valor que chega ao sistema. 
	\item \textbf{Cálculos estatísticos}: este componente da camada de lógica de negócio ganha especial relevância na altura em que se pretende determinar os valores médios, máximos e mínimos de um conjunto de medições para um determinado intervalo de tempo. 
	\item \textbf{Comunicação via \ac{API}}: este componente é fundamental para que se possa aceder, atualizar ou adicionar dados ao sistema de um modo simples.
\end{itemize}



Relativamente à camada de acesso a dados, deverão estar presentes as funcionalidades de criação, edição, remoção ou simples visualização dos dados, sendo responsável pelas operações de persistência e consulta de dados solicitados pela camada de lógica de negócio.


\section{Arquitetura física}


Enquanto que a arquitetura lógica se concentra nos diferentes níveis de abstração do sistema a arquitetura física foca-se na estrutura de alto nível.  
Seguidamente são apresentados todos os componentes físicos, tanto  a nível de \textit{software} como de \textit{hardware}, que são fundamentais para ter uma maior perceção do real funcionamento de todo o sistema. 
A figura \ref{fisicablocos} representa genericamente os blocos principais do sistema proposto que seguidamente serão descritos. 


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.51]{esquemas/esquema-blocos.pdf}
	\caption{Arquitetura física (blocos principais)}
	\label{fisicablocos}
\end{figure}


  
\subsection{Sistema de informação}




A figura \ref{arquiteturasi} ilustra a arquitetura do sistema de informação incluindo especificamente a aplicação \textit{web} (\textit{dashboard}), base de dados, \acs{API}   e respetiva implementação do sistema. 





\subsection{Aplicação \textit{web}}

A aplicação \textit{web} é um componente essencial, enquadrando-se tanto na camada de lógica de negócio como também na camada de apresentação, permitindo a interação tanto por parte do utilizador (\textit{frontend}) como também no processamento lógico (\textit{backend}).   

Tal como vimos na secção \ref{django-conclusao} do Estado de Arte, a tecnologia para o desenvolvimento \textit{web} recaiu sobre a \textit{framework} Django, mais precisamente na versão 1.11 para python 2.7, sendo que como \ac{IDE} foi utilizada a verão 2016.3.3 do PyCharm. Dada a facilidade com que esta \textit{framework} tem em manipular \textit{views} e \textit{templates}, optou-se que ambas as componentes (\textit{frontend}/\textit{backend}) fossem desenvolvidas recorrendo ao Django. Para além disso, optou-se por criar uma API REST que permitisse a manipulação dos dados existentes na base de dados, sendo esta também desenvolvida paralelamente com a aplicação \textit{web}. Seguidamente será explicada a sua arquitetura.   



\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{esquemas/fisica-si.pdf}
	\caption{Arquitetura do sistema de informação (\textit{dashboard}, base de dados e API)}
	\label{arquiteturasi}
\end{figure}




Como descrito na secção \ref{django}, o Django permite modelar os dados através de classes, possibilitando gerar tabelas na base de dados de uma forma quase direta, sem recorrer ao \ac{SQL}. A verificação dos valores lidos pelos sensores e possível geração de alarmes é averiguado por um \textit{trigger} desenvolvido em \ac{SQL}. No capítulo \ref{implementacao} será explicada a sua implementação.  


Relativamente à escolha do \ac{SGBD} recaiu sobre o PostgreSQL, mais concretamente na versão 9.3.16. Como ferramenta gráfica para administração deste \ac{SGBD} foi utilizado o PgAdmin III\footnote{\url{www.pgadmin.org/}} na versão 1.22. Este \textit{software} com interface gráfica tem inúmeras funcionalidades desde a possibilidade de ligação a base de dados remotas até à adição, edição, remoção e consulta em tabelas. Esta ferramenta é \textit{open-source} e encontra-se disponível para Windows e UNIX. Como vimos no capítulo \ref{state}, este \ac{SGBD} permite com grande facilidade a incorporação a um projeto Django. 


No que diz respeito à camada de apresentação na plataforma \textit{web} foram utilizadas as seguintes linguagens/bibliotecas/\textit{frameworks}: 

\begin{itemize}
	\item \textbf{\acs{HTML}, \acs{CSS} e \acs{JS}}: o ponto de partida para a criação da interface \textit{web} assentou no \textit{template} denominado por AdminLTE\footnote{\url{https://adminlte.io/}} sendo este baseado em Bootstrap 3\footnote{\url{http://getbootstrap.com/}}. Neste \textit{template} prevalecem as seguintes características:  \textit{design} responsivo, interface leve e apelativa, existência de múltiplos \textit{plugins}, compatibilidade entre navegadores, entre outros. 
	
	\item \textbf{Gravatar}: serviço que disponibiliza um avatar que esteja associado a um endereço de email registado. O Gravatar disponibiliza uma \ac{API} que pode ser utilizada nas mais diversas linguagens de programação\cite{gravatar}.
	 
	\item \textbf{\ac{API} Google Maps}: consiste num serviço de visualização de mapas e imagens de satélite, desenvolvido pela Google. É usado na visualização da localização dos módulos de sensores. 
	
	\item \textbf{ZingChart}: biblioteca em \ac{JS} que permite receber dados e apresentá-los em formato gráfico. Esta solução \textit{open-source} disponibiliza mais de 35 tipos de gráficos. 
\end{itemize}





\subsection{\acs{API} \acs{REST}}


Os métodos desenvolvidos para esta \ac{API} permitiram executar funções do tipo \ac{REST}. A tecnologia \ac{REST} foi apresentada por Roy Fielding na Universidade de Califórnia no ano de 2000\cite{restpaper}. Roy, estudou um conjunto de arquiteturas de \textit{software} que usam a \textit{web} como uma plataforma para computação distribuída\cite{restpaper}. Esta tecnologia define um conjunto de princípios que possibilitam desenhar serviços \textit{web} com base nos recursos existentes num determinado sistema. Nesta arquitetura, é considerada a forma como os recursos são coordenados e transferidos através do protocolo \ac{HTTP} para os vários clientes nas mais diversas linguagens. 

Os métodos da API permitem executar as funções \ac{REST} usando métodos \ac{HTTP} explicitamente. Assim, torna-se fundamental perceber estes métodos para ter um melhor conhecimento do funcionamento da \ac{API}. Seguidamente são descritos os métodos mais importantes que dão suporte a cada uma das funções \ac{REST}.


\begin{itemize}
	\item \textbf{GET}: permite efetuar operações de leitura;
	\item \textbf{POST}: permite realizar operações de escrita, possibilitando criar novos recursos ao sistema;
	\item \textbf{PUT}: permite criar ou atualizar um novo objeto ao sistema;  
	\item \textbf{DELETE}: permite apagar objetos ou recursos ao sistema. 
\end{itemize}




Como vimos no capítulo \ref{state}, a escolha da \textit{framework} para construção desta \ac{API} \ac{REST} recaiu sobre o \textit{Django REST framework}. Esta ferramenta possui uma extensa documentação e um elevado apoio da comunidade que a utiliza, sendo uma das mais utilizadas e incorporadas em projetos Django. 

Relativamente à autenticação desta \ac{API}, optou-se por utilizar um esquema de autenticação suportado no mecanismo de autenticação \ac{HTTP} baseado em \textit{tokens}\cite{tokenREST}. Neste mecanismo, o cliente primeiramente troca as suas credencias (\textit{username} e \textit{password}) por um \textit{token}, seguidamente, em vez de enviar essas credenciais a cada requisição, o cliente apenas enviará o \textit{token} inicialmente recebido, permitindo assim o acesso aos conteúdos pretendidos, com respetiva autenticação e autorização dos mesmos (figura \ref{autnetAPI}).


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.61]{esquemas/autenticacaohttpesquema.pdf}
	\caption[Processo de autenticação em \acs{HTTP} através de \textit{token}]{Processo de autenticação em \ac{HTTP} através de \textit{token} (Adaptado de \cite{AdoKukic2016})}
	\label{autnetAPI}
\end{figure}


Resumidamente e com o objetivo de explicar o esquema da figura \ref{autnetAPI}, são enumerados os passos de autenticação em \ac{HTTP} via \textit{token}. 

\begin{enumerate}
	\item O cliente envia as credenciais para um servidor;
	\item O servidor valida e autentica essas credenciais gerando consequentemente um \textit{token};
	\item O servidor envia o \textit{token} para o cliente;
	\item O cliente guarda o \textit{token} e este é enviado sempre que existe uma requisição através do cabeçalho do protocolo HTTP; 
	\item O servidor, em cada requisição verifica se o \textit{token} é válido ou não. Caso seja, o servidor aceita a requisição, caso contrário esta é rejeitada;
	\item O servidor pode ter um \textit{endpoint} que renova o \textit{token} sempre que necessário. 
\end{enumerate}




Na tabela \ref{endpointsapi} encontram-se todos os \textit{endpoints} e respetivas funções (POST/GET/PUT) a implementar. Seguidamente será descrito como foi implementada a documentação interativa desta \ac{API}.  




\begin{table}[h]
	\centering

	\begin{tabular}{|l|l|l|l|l|}
		\hline
		\rowcolor[HTML]{EFEFEF} 
		\multicolumn{1}{|c|}{\cellcolor[HTML]{EFEFEF}\textbf{\textit{Endpoints} da \ac{API} \ac{REST}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{POST}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{GET}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{PUT}} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{DELETE}} \\ \hline
		/api/user/ & \checkmark & \checkmark &  &  \\ \hline
		/api/user/\{pk\_or\_username\}/ &  & \checkmark & \checkmark & \checkmark \\ \hline
		/api/smpercm/ &  & \checkmark &  &  \\ \hline
		/api/smpercm/\{pk\_or\_name\_cm\} & \checkmark & \checkmark &  &  \\ \hline
		/api/sm/ & \checkmark & \checkmark &  &  \\ \hline
		/api/sm/\{pk\_or\_name\}/ &  & \checkmark & \checkmark & \checkmark \\ \hline
		/api/sensortype/ & \checkmark & \checkmark &  &  \\ \hline
		/api/sensortype/\{pk\_or\_name\} &  & \checkmark & \checkmark & \checkmark \\ \hline
		/api/sensorpersm/\{id\_sm\_or\_name\_sm\} & \checkmark & \checkmark &  &  \\ \hline
		/api/sensor/ &  & \checkmark &  &  \\ \hline
		/api/sensor/\{pk\_or\_sensor\_type\} & \checkmark & \checkmark &  &  \\ \hline
		/api/reading/\{id\_sensor\}/\{date\_start\}/\{date\_end\} & \checkmark & \checkmark &  &  \\ \hline
		/api/communication/\{pk\_or\_name\}/ &  & \checkmark & \checkmark & \checkmark \\ \hline
		/api/cm/ & \checkmark & \checkmark &  &  \\ \hline
		/api/cm/\{pk\_or\_name\}/ &  & \checkmark & \checkmark & \checkmark \\ \hline
		/api/alarmssettings/\{id\_sensor\} & \checkmark & \checkmark &  &  \\ \hline
		/api/alarms\_sensor/\{id\_sensor\} & \checkmark & \checkmark &  &  \\ \hline
		/api/alarms\_reading/\{id\_reading\} & \checkmark & \checkmark &  &  \\ \hline
	\end{tabular}
	\caption{\textit{Endpoints} da \ac{API} \ac{REST} e respetivos métodos a implementar}
	\label{endpointsapi}
\end{table}






\subsection{Documentação interativa}


Para a geração automática da documentação da \ac{API} utilizou-se o Swagger. Tal como descrito no site oficial desta \textit{framework}\cite{SmartBearSoftware2017}, o Swagger é considerado a ferramenta de APIs mais popular e completa de todo o mundo permitindo facilmente o desenvolvimento do ciclo de vida de uma \ac{API}, desde o \textit{design}, documentação, testes e também implementação, tendo a grande vantagem de ser \textit{open-source}. Neste contexto, apenas será utilizada como documentação, de modo a facilitar a interpretação da \ac{API} criada. O Swagger possui uma interface apelativa e intuitiva, permitindo interagir com a \ac{API} de modo que os seus utilizadores tenham uma ideia geral de como esta responde aos pedidos para diversos parâmetros e opções. 





\subsection{Implementação do sistema}

Para implementação do projeto anteriormente descrito e respetiva API, foi-me disponibilizada uma máquina virtual com uma distribuição Linux (Ubuntu 14.04.5) com as seguintes características: 

\begin{itemize}
	\item \ac{CPU}: Intel(R) Xeon(R) CPU E5-2670 v3 @ 2.30 GHz
	\item \ac{RAM}: 2 GB
	\item Disco: 10.7 GB
\end{itemize}


Para o processo de \textit{deployment} do projeto optou-se pela utilização do servidor Apache juntamente com o pacote mod\_wsgi\footnote{\url{https://modwsgi.readthedocs.io/en/develop/}}. 
Este pacote fornece uma \ac{WSGI} compatível para o alojamento de aplicações \textit{web} em Python sob o servidor \ac{HTTP} Apache. O Apache é um dos servidores \textit{web} \textit{open-source} mais  populares no mundo\cite{TheApacheSoftwareFoundation2016}.







% implementação falar da incorporação na dashboard e poss





%\section{Documentação automática}

%\subsection{Documentação API}












\subsection{Aplicação mobile}


Após a análise de requisitos da aplicação \textit{mobile}, elaborou-se um protótipo desta antes de proceder à sua real implementação. O \textit{mockup} da aplicação apresenta-se no Apêndice \ref{Mockup}. 

\begin{figure}[h]
	\centering
	\includegraphics[scale = 0.4]{esquemas/arquitetura-mobile.pdf}
	\caption{Arquitetura da aplicação \textit{mobile} com respetivas tecnologias}
	\label{arquiteturamobile}
\end{figure}

\newpage


Tal como descrito no capítulo \ref{state} (Estado da Arte), para o desenvolvimento da aplicação \textit{mobile} optou-se pela utilização de um paradigma multi-plataforma, mais concretamente a \textit{framework} Phonegap. Esta \textit{framework} utiliza a tecnologia Cordova da Apache que permite a integração com recursos nativos dos dispositivos. Através dela, é possível desenvolver aplicações móveis utilizando simplesmente \ac{HTML}, \ac{CSS} e \ac{JS} sem a necessidade de depender de APIs específicas. De modo a facilitar a manipulação do \ac{JS} optou-se por utilizar a \textit{framework} Angular2. Esta biblioteca \textit{open source} mantida pela Google desde 2010, segue uma arquitetura \ac{MVC} e será utilizada para permitir a abstração da manipulação do \ac{DOM} e facilitar a criação/utilização de rotas\cite{Google2015}.



\newpage
\subsection{Simulação em \textit{hardware}}
\label{arq-hardw}


Após o desenvolvimento da \ac{API}, simulou-se o sistema num contexto real. Para tal, pretendia-se encontrar \textit{hardware} que encaixasse no contexto deste projeto. Foram utilizados dois microcontroladores (Arduino Nano e Raspberry Pi 3) e alguns sensores. Para este cenário, assume-se que o Arduino Nano é considerado um \acl{SM} que possui um conjunto de sensores e atuadores enquanto que o Raspberry Pi 3 é um \acl{CM} que recebe os dados provenientes do \acl{SM} enviando-os para o servidor através da API.  

Seguidamente, são apresentados os sensores bem como os tipos de comunicação utilizados. 
 

\subsubsection{Sensores utilizados}

Nesta secção apresentam-se os sensores utilizados na simulação e as suas principais características. Todos os sensores foram escolhidos tendo em conta o seu enquadramento no projeto e a sua disponibilidade em laboratório. \\


\textbf{Temperatura}


Como sensor de temperatura foi utilizado um termístor do tipo \ac{NTC} (figura \ref{temp_imag}). Como vimos no capítulo \ref{state}, um termístor é um semicondutor sensível à temperatura, ou seja, quando o coeficiente de variação da resistência com a temperatura é negativa, então a temperatura sobe e consequentemente a resistência diminui. Na figura \ref{esquema-temp} encontra-se o esquema de ligação deste componente e na tabela \ref{table-temp} as suas propriedades principais\cite{temp-dta}. 


\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.6\textwidth]{img/hardware/temperatura.jpg}
		\caption{Sensor TTC 104 NTC}
		\label{temp_imag}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.65\textwidth]{img/hardware/temp-esquema.pdf}
		\caption{Esquema eletrónico da ligação do sensor de temperatura}
		\label{esquema-temp}
	\end{minipage}
\end{figure}


\newpage

\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|} \hline
		\textbf{Dimensão} & 5mm \\ \hline
		\textbf{Resistência} & 100 K$\Omega$  \\ \hline
		\textbf{Valor máximo} & +125 $^{\circ}$C \\ \hline
		\textbf{Valor mínimo} & -30 $^{\circ}$C \\ \hline
		\textbf{Nível de confiança} & $\pm$ 10\% \\ \hline
		\textbf{Preço} & 0.35 \euro/unidade \\ \hline
	\end{tabular}
	\caption[Características do sensor TTC 104]{Características do sensor TTC 104 (Adaptado de \cite{temp-dta})}
	\label{table-temp}
\end{table}




\textbf{Luminosidade}



Para simular a luminosidade incidente foi utilizado um sensor do tipo foto-resistência, neste caso, o GL5528 (figura \ref{cGL5528}). Este sensor, também conhecido como \ac{LDR}, não é mais do que uma resistência variável cujo o seu valor varia conforme a intensidade da luz que incide sobre ele, isto é, à medida que a intensidade da luz aumenta, a sua resistência diminui. Este sensor tem múltiplas aplicações, entre as quais se destaca a monitorização solar, indicador da posição do sol (\textit{up}/\textit{down}), alarmes anti-roubo, alarme para abertura/fecho de portas entre outras. Como vimos no capítulo \ref{state}, é um sensor de baixo custo e de fácil utilização. Na figura \ref{lum-esquema} encontra-se o esquema de ligação do componente e na tabela \ref{lum-cara} são apresentadas as principais características do sensor utilizado. 







\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.5\textwidth]{img/hardware/luminosidade.png}
		\caption{Sensor de foto-resistência GL5528}
		\label{cGL5528}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.65\textwidth]{img/hardware/lumi_esquema.pdf}
		\caption{Esquema eletrónico da ligação do sensor de luminosidade}
		\label{lum-esquema}
	\end{minipage}
\end{figure}







\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|} \hline
		\textbf{Diâmetro} & 5 mm \\ \hline
		\textbf{Tensão máxima} & 150 VDC \\ \hline
		\textbf{Potência máxima} & 100 mW \\ \hline
		\textbf{Tensão de operação} & -30 $^{\circ}$C a 70 $^{\circ}$C \\ \hline
		\textbf{Espectro} &540 nm \\ \hline
		\textbf{Comprimento com terminais} & 32 mm \\ \hline
		\textbf{Resistência na luz} &10-20 K$\Omega$ (Lux 10) \\ \hline
		\textbf{Material} & Carbono \\ \hline
		\textbf{Preço} & 0.22 \euro/unidade \\ \hline
	\end{tabular}
	\caption[Características do sensor GL5528]{Características do sensor GL5528 (Adaptado de \cite{lum-data})}
	\label{lum-cara}
\end{table}




\textbf{Sensor para verificação do estado do nível de água}

Este sensor, denominado por \textit{Water Level Switch Liquid Level Sensor Plastic Ball Float} (figura \ref{levelimg}),  não é mais do que um interruptor que é ativado sempre que um determinado líquido ultrapassa o mesmo, isto é, sempre que algum líquido atingir o pedaço de plástico este irá subir ativando assim o circuito. Na figura \ref{esquem-liquido} encontra-se o esquema da ligação deste sensor.




\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.5\textwidth]{img/hardware/liquido.JPG}
		\caption{\textit{Water Level Switch Liquid Level Sensor Plastic Ball Float}}
		\label{levelimg}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.75\textwidth]{img/hardware/sw_esquema.pdf}
		\caption{Esquema eletrónico da ligação do sensor de nível líquido}
		\label{esquem-liquido}
	\end{minipage}
\end{figure}



\textbf{Simulador de válvula para transferências de águas}

Para a simulação de uma válvula que permitirá a transferência de água doce e/ou água salgada foi utilizado um \ac{LED}. Este possibilita facilmente identificar através da sua ativação se a válvula se encontra ativa ou não. Na figura \ref{ligacao} encontra-se o esquema de ligação deste componente. 


\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{img/hardware/led.jpg}
		\caption{\ac{LED}}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.65\textwidth]{img/hardware/led_esquema.pdf}
		\caption{Esquema eletrónico da ligação do \ac{LED}}
		\label{ligacao}
	\end{minipage}
\end{figure}



\subsubsection{Comunicação}

Nesta secção, apresentam-se os tipos de comunicação para o cenário escolhido. Pretendia-se que cada um dos módulo ficasse isolado, o que implicou o estudo e respetiva escolha de algumas tecnologias de comunicações sem fios (secção \ref{state-tecc} do capítulo \ref{state}). 

De acordo com o verificado na tabela \ref{com-tecn}, o Zigbee, o LoRa e o Sigfox apresentam as características que melhor se adaptam ao universo do \acl{IoT}. No entanto,  para o contexto deste trabalho, apenas se encontram disponíveis em laboratório módulos Wi-fi e Bluetooth. Embora estas tecnologias possuam um baixo alcance relativamente às restantes estudadas, foram utilizados estes dois tipos de comunicação. 

\begin{itemize}
	\item \textbf{Bluetooth}: utilizado para a comunicação entre o Arduino Nano e o Raspberry Pi 3. No Arduino, foi utilizado um módulo Bluetooth HC-06 e no caso do Raspberry Pi 3 foi utilizado o seu módulo interno (versão 4.1). 
	\item \textbf{Wi-Fi}: utilizado para a comunicação entre o Raspberry Pi 3 e o servidor \textit{web}, sendo utilizado o seu módulo interno (802.11.g). 
\end{itemize}


O esquema da figura \ref{esquemcomm} ilustra os tipos de comunicação envolvidos nesta simulação para cada um dos componentes. 

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{img/comm-blue/HW-geral.pdf}
	\caption{Comunicação entre componentes da simulação em \textit{hardware}}
	\label{esquemcomm}
\end{figure}




\textbf{Módulo Bluetooth HC-06}



Este módulo Bluetooth oferece uma forma simples de envio e receção de informações remotamente, podendo ser adquirido a um custo reduzido. Este componente funciona apenas em modo \textit{slave}, isto é, apenas permite que outros dispositivos se liguem a si, mas não permite que ele próprio se ligue a outros. Para além disso, possui um \ac{LED} que permite indicar se algum dispositivo está emparelhado. É um dos módulos Bluetooth mais comuns para o microcontrolador Arduino, possuindo um alcance máximo de aproximadamente 10 metros\cite{GuangzhouHCInformationTechnologyCo.2011}.


Na figura \ref{comimageesquema} encontra-se o esquema de ligação deste módulo e na tabela \ref{cara-comm} são apresentadas as suas principais características.

\newpage

\begin{figure}[h]
	\centering
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.6\textwidth]{img/hardware/bluetooth_zs-040.png}
		\caption{Módulo Bluetooth HC-06}
		\label{comimage}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.49\textwidth}
		\centering
		\includegraphics[width=0.6\textwidth]{img/comm-blue/electronic-sensors.pdf}
		\caption{Esquema eletrónico da ligação do módulo Bluetooth}
		\label{comimageesquema}
	\end{minipage}
\end{figure}



\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|} \hline		
		\textbf{Versão Bluetooth}& v2.0 com \ac{EDR}\\ \hline 
		\textbf{Frequência}& 2,4GHz Banda \ac{ISM} \\ \hline
		\textbf{Segurança}& Autentificação (PIN) e Encriptação  \\ \hline
		\textbf{Tensão}& Aconselhada 3,3v (2,7v - 4.2v) \\ \hline
		\textbf{Alcance}& 10 metros \\ \hline
		\textbf{Dimensões}& 26,9 x 13 x 2,2mm \\ \hline
		\textbf{Peso}& 9,6g \\ \hline
		\textbf{Temperatura (funcionamento)}& -25C +75C \\ \hline 
		
		\textbf{Preço}&5.26 \euro /unidade  \\ \hline
	\end{tabular}
	\caption[Características do módulo bluetooth HC-06]{Características do módulo bluetooth HC-06 (Adaptado de \cite{GuangzhouHCInformationTechnologyCo.2011})}
	\label{cara-comm}
\end{table}




%http://www.instructables.com/id/Modifying-the-AT-Codes-on-a-HC-05-With-the-Code-ZS/


%http://www.arduinoecia.com.br/2013/03/modulo-bluetooth-jy-mcu-configuracao.html








\subsection{Sistema de videovigilância }
\label{videoviarqut}


No contexto desta dissertação surgiu a necessidade de implementar um sistema de videovigilância que permitisse detetar intrusos, maioritariamente pessoas ou animais de grande porte, que possam invadir as quintas onde se produz Salicórnia. Esta necessidade prende-se essencialmente com o elevado custo do \textit{hardware} do sistema de monitorização e também de eventuais instrumentos de elevado custo necessários ao cultivo desta espécie, como por exemplo,  geradores, máquinas elétricas para poda, entre outros. 

%Neste secção é descrita a tecnologia de processamento de imagem utilizada tal como o material necessário e respetiva arquitetura. 






%\begin{figure}[!htb]
%	\centering
%	\includegraphics[width=0.3\linewidth]{img/vision/opencv_logo.jpg}
%	\caption{Logótipo OpenCV}
%	\label{opencvlogo}
%\end{figure}





Desde logo, a escolha da tecnologia para processamento de imagem recaiu sobre o OpenCV não apenas por ser uma biblioteca bastante popular e possuir bastantes algoritmos implementados mas também por eu próprio possuir já algum \textit{background} e projetos desenvolvidos nesta área. Pretendia-se que este processamento fosse implementado em material já adquirido sem necessidade de gastos. Optou-se então por utilizar um \textit{Raspberry Pi 3} que juntamente com um \textit{Raspberry Pi camera module} (figura \ref{raspicam}) permitirá a aquisição da imagem e servirá também como \acl{CM} ao sistema de aquisição de dados. Na tabela \ref{cara-cam} apresentam-se algumas características deste módulo para o Raspberry Pi 3.
\newpage
 


\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.25\linewidth]{img/hardware/camera_v2.jpg}
	\caption{Raspberry Pi Camera Board V2 8MP 1080p}
	\label{raspicam}
\end{figure}






\begin{table}[h]
	\centering
	
	\begin{tabular}{|
			>{\columncolor[HTML]{EFEFEF}}l |l|} \hline		
		\textbf{Sensor} & 8 megapixels Sony IMX219 \\ \hline
		\textbf{Resolução de exibição} & 1080p, 720p e 640x480p para vídeo \\ \hline
		\textbf{Ligação à placa}& Cabo fita curta (branca) \\ \hline
		\textbf{Dimensões}& 25 x 23 x 9 mm \\ \hline
		\textbf{Peso}& aproximadamente 3 g \\ \hline
		\textbf{Compatibilidades}& ultima versão do Raspbian \\ \hline
		\textbf{Preço}& 26,67 \euro /unidade  \\ \hline
	\end{tabular}
	\caption[Características do módulo bluetooth HC-06]{Características do Raspberry Pi camera module}
	\label{cara-cam}
\end{table}







Inicialmente, após incorporar o \textit{Raspberry Pi camera module} no Raspberry Pi 3 através do \ac{CSI} (imagem 3.5 da secção 3.6.2), testou-se a captura de vídeo através do raspivid. Esta ferramenta de linha de comando, permite testar o funcionamento do módulo, e para além disso, definir em que formato será guardado o vídeo adquirido, bem como o seu comprimento e as suas dimensões\cite{raspivid}. Posteriormente, procedeu-se ao envio da imagem capturada, sem qualquer processamento, para o Youtube Live através da ferramenta FFMpeg.


Na figura \ref{arquiteturavisao} encontra-se a arquitetura do sistema de videovigilância anteriormente descrito. No próximo capítulo será apresentado o algoritmo de deteção de intrusos disponibilizado pela ferramenta OpenCV. 







%Inicialmente, explorou-se um algoritmo disponibilizado pelo OpenCV para a deteção de pessoas (corpo inteiro). Este algoritmo, juntamente com técnicas de \textit{machine learning}  permitem a deteção de pessoas numa determinada imagem e/ou vídeo. O \textit{machine learning} (em português aprendizagem automática) consiste num  método de análise de dados que automatiza o desenvolvimento de modelos analíticos, sendo usados algoritmos que aprendem interativamente a partir de dados recolhidos à priori\cite{Kotsiantis2007}. 

%Após a realização de vários testes a este algoritmo, pretendeu-se implementar um servidor de \textit{streaming} que possa ser incorporado na \textit{dashboard}. Para tal, optou-se por criar um aplicação em Flask (\textit{framework} abordada no capitulo \ref{state}) que permita a aquisição de vídeo proveniente da  \textit{Raspberry Pi camera module} e realização do respetivo processamento. Esta aplicação web foi implementada num \textit{Raspberry Pi 3} tendo sido necessário optar por um servidor web, neste caso o NGINX\footnote{https://www.nginx.com/resources/wiki/}. O NGINX é um servidor HTTP de alto desempenho e open-source. É conhecido pela sua alta performance, estabilidade, configuração simples e baixo consumo de recursos\cite{Nginx2017}. 

%Para comunicação entre o servidor web com a aplicação em Flask foi necessária a utilização de uma \ac{CGI} que permita gerir páginas dinâmicas, possibilitando ao navegador passar parâmetros para uma aplicação existente num servidor web. Optou-se por utilizar o uWSGI \footnote{https://uwsgi-docs.readthedocs.io}, sendo um dos mais populares. Na figura \ref{arquiteturavisao} encontra-se a arquitetura do sistema de deteção de intrusos e as respetivas tecnologias utilizadas.



\begin{figure}[h]
	\centering
	\includegraphics[scale = 0.39]{esquemas/videostream.pdf}
	\caption{Arquitetura do sistema de videovigilância e deteção de intrusos }
	\label{arquiteturavisao}
\end{figure}



\subsubsection{Biblioteca para processamento de imagem: OpenCV}

O OpenCV, também conhecido por \textit{Open Source Computer Vision Library}, é uma biblioteca de \textit{software} de visão por computador de código \textit{open-source}. Esta biblioteca possui mais de 2500 algoritmos otimizados, que inclui um conjunto abrangente de algoritmos clássicos e avançados de visão computacional bem como algoritmos de \textit{machine learning}. Esses algoritmos podem ser utilizados para os mais diversos fins, como por exemplo, para detetar e reconhecer rostos, identificar objetos, classificar ações humanas em vídeos, detetar movimentos numa câmara, seguir objetos em movimento, entre outros. Esta biblioteca é amplamente utilizada em empresas e grupos de investigação, tendo interfaces nas mais diversas linguagens: C++, C, Python, Java e MATLAB, embora seja nativamente escrita na linguagem C. OpenCV tem mais de 47 mil pessoas na sua comunidade e excede os 7 milhões de \textit{downloads}, tendo suporte para Windows, Linux e Mac OS\cite{Itseez}.



\subsubsection{\textit{Streaming} de vídeo: Youtube Live}

 O Youtube Live permite que qualquer utilizador possa realizar \textit{streaming} de vídeo, possibilitando escolher entre dois modos: alta latência e baixa latência, isto é, boa ou má qualidade. Uma das grandes vantagens desta ferramenta é manter a \textit{stream} transmitida permitindo consultá-la quando desejado. O Youtube Live utiliza o protocolo \ac{RTMP}, pertencente à camada protocolar TCP/IP, mantendo uma conexão persistente com um servidor que permite a comunicação em tempo real de vídeo ou áudio. Por outro lado, o FFMpeg é uma ferramenta líder, capaz de codificar ou descodificar qualquer tipo de conteúdo, possibilitando a criação ou conversão de \textit{stream} de vídeo/áudio em qualquer formato. É uma ferramenta \textit{open-source} sendo que a sua interação é concretizada através de linha de comandos\cite{FFmpeg2015}. 




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Diagrama de componentes}

Para o cenário de simulação em \textit{hardware} e respetivo sistema de informação, em que se inclui a \textit{dashboard}, a \ac{API}, aplicação \textit{mobile} e o sistema de videovigilância, obteve-se o diagrama de componentes apresentado na figura \ref{componentesall}. 

No que toca à comunicação entre os diferentes componentes, esta baseia-se essencialmente na API REST que foi criada, embora no caso do sistema de videovigilância seja utilizado um serviço externo (Youtube Live). Por fim, para a comunicação entre \acl{CM} e o \acl{SM} no cenário de simulação é utilizada a tecnologia Bluetooth. 



\newpage

\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{esquemas/arquitetura-final.pdf}
	\caption{Diagrama final de componentes do sistema}
	\label{componentesall}
\end{figure}







\section{Considerações finais}


Neste capítulo foi projetada toda a arquitetura do sistema, tendo por base os requisitos do cliente e a respetiva modelação. Para além disso, a arquitetura anteriormente apresenta foi concebida tendo como garantia que poderia ser adaptada a quaisquer outros cenários distintos do apresentado. Esta arquitetura é apoiada através da exposição de diagramas de arquitetura, casos de uso e modelo de dados. 







